var documenterSearchIndex = {"docs":
[{"location":"repl/rendering/#Rendering","page":"Rendering","title":"Rendering","text":"","category":"section"},{"location":"repl/rendering/","page":"Rendering","title":"Rendering","text":"Rendering a scene needs the following ingredients:","category":"page"},{"location":"repl/rendering/","page":"Rendering","title":"Rendering","text":"hdrimg holds the HDR image data.\nAbstractCamera object defines the camera parameters.\nPCG is  a pseudo-random number generator used for integration and sampling.\nrenderer is an instance of Function that take World and optionally a PCG object, instructing on how a ray should be traced through the scene.\nImageTracer is a function that takes the hdrimg, AbstractCamera, and renderer (and optionally a PCG) to render the scene.","category":"page"},{"location":"repl/rendering/","page":"Rendering","title":"Rendering","text":"First we need to create an hdrimg object to hold the rendered image data. The hdrimg constructor takes the width and height of the image as parameters.","category":"page"},{"location":"repl/rendering/#jujutracer.hdrimg","page":"Rendering","title":"jujutracer.hdrimg","text":"struct hdrimg(w::Int, h::Int)\n\nA struct representing a high dynamic range image (HDR image). Getter and setter methods are defined for accessing and modifying pixel values. Access is done using 0-based indexing, so the first pixel is at (0, 0): img[0, 0]; while the bottom right pixel is at (w-1, h-1): img[w-1, h-1].\n\n    img = [ (0  , 0)   (0  , 1) ... (0  , w-1)\n            (1  , 0)   (1  , 1) ... (1  , w-1)\n             ...\n            (h-1, 1)   (h-1, 2) ... (h-1, w-1) ]\n\nFields\n\nimg::Matrix{RGB}: A matrix of RGB values representing the HDR image. Not intedend to be accessed directly.\nw::Int64: The width of the image in pixels.\nh::Int64: The height of the image in pixels.\n\n\n\n\n\n","category":"type"},{"location":"repl/rendering/","page":"Rendering","title":"Rendering","text":"The we can set the camera. We have two types of cameras: Perspective and Orthogonal, both subtypes of AbstractCamera.","category":"page"},{"location":"repl/rendering/#jujutracer.Perspective","page":"Rendering","title":"jujutracer.Perspective","text":"Perspective\n\nPerspective camera type\n\nFields\n\nt::Transformation the transformation related to the camera's standing\na_ratio::Float64 aspect ratio of the screen of the camera\n\nConstructor\n\nPerspective() creates a perspective camera with Identity Transformation, a 16:9 aspect ratio placed in (-1, 0, 0)\nPerspective(d = dist, t = trans, a_ratio = a) creates a perspective camera with trans Transformation, an a aspect ratio placed in (-d, 0, 0)\n\n\n\n\n\n","category":"type"},{"location":"repl/rendering/#jujutracer.Orthogonal","page":"Rendering","title":"jujutracer.Orthogonal","text":"Orthogonal\n\nOrthogonal camera type\n\nFields\n\nt::Transformation the transformation related to the camera's standing\na_ratio::Float64 aspect ratio of the screen of the camera\n\nConstructor\n\nOrthogonal() creates an orthogonal camera with Identity Transformation and a 16:9 aspect ratio\nOrtoghonal(t = trans, a_ratio = a) creates an orthogonal camera with trans Transformation and an a aspect ratio\n\n\n\n\n\n","category":"type"},{"location":"repl/rendering/","page":"Rendering","title":"Rendering","text":"A PCG object is used for pseudo-random number generation.","category":"page"},{"location":"repl/rendering/#jujutracer.PCG","page":"Rendering","title":"jujutracer.PCG","text":"mutable struct PCG\n\nA Pseudo-Random Number Generator (PRNG) based on the PCG algorithm.\n\nFields\n\nstate::UInt64: The current state of the PCG. It is atomically wrapped to ensure thread safety.\ninc::UInt64: The increment value used in the PCG algorithm.\n\nConstructor\n\nPCG(init_state::UInt64, init_seq::UInt64): Creates a new PCG instance with the given initial state and sequence. Defaults are 42 and 54 respectively.\n\n\n\n\n\n","category":"type"},{"location":"repl/rendering/#Renderers","page":"Rendering","title":"Renderers","text":"","category":"section"},{"location":"repl/rendering/","page":"Rendering","title":"Rendering","text":"We have several renderers available, each with different complexity and quality.","category":"page"},{"location":"repl/rendering/#jujutracer.OnOff","page":"Rendering","title":"jujutracer.OnOff","text":"OnOff(world::World)\n\nOnOff renderer of the scene. Returns white if the ray hits something, balck otherwise\n\nFields\n\nworld::World the world containing the scene\nbackground_color::RGB the color of the background when the ray doesn't hit anything\nforeground_color::RGB the color of the foreground when the ray hits something\n\nFunctional Usage\n\nOnOff(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"repl/rendering/#jujutracer.Flat","page":"Rendering","title":"jujutracer.Flat","text":"Flat(world::World)\n\nFlat renderer of the scene. Returns the Emition pigment of the hitten shapes\n\nFields\n\nworld::World the world containing the scene\n\nFunctional Usage\n\nFlat(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"repl/rendering/#jujutracer.PathTracer","page":"Rendering","title":"jujutracer.PathTracer","text":"PathTracer(world::World, backg::RGB, rnd::PCG, n_rays::Int64, depth::Int64, russian::Int64)\n\nPath Tracer renderer of the scene.\n\nFields\n\nworld::World: the world containing the scene\nbackg::RGB: the background color when the ray doesn't intersect anything\nrnd::PCG: the random number generator\nn_rays::Int64: the number of rays fired from the hitten point\ndepth::Int64: the maximum depth to be reached by a ray\nrussian::Int64: number of iteration before playing with Russian Roulet\n\nFunctional Usage\n\nPathTracer(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"repl/rendering/#jujutracer.PointLight","page":"Rendering","title":"jujutracer.PointLight","text":"PointLight(world::World, background::RGB, ambient::RGB, max_depth::Int64)\n\nPointLight renderer of the scene. Backtraces the light from the point light sources.\n\nFields\n\nworld::World: the world containing the scene. Must contain at least one light source\nbackground_color::RGB: the color of the background when the ray doesn't hit anything\nambient_color::RGB: the ambient color of the scene\nmax_depth::Int64: the maximum depth of the ray tracing\n\nFunctional Usage\n\nPointLight(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"repl/rendering/#Rendering-process","page":"Rendering","title":"Rendering process","text":"","category":"section"},{"location":"repl/rendering/","page":"Rendering","title":"Rendering","text":"The rendering process is initiated by calling the ImageTracer on a hdrimage. Optionally, a PCG object can be passed to the ImageTracer for antialising and stratified sampling.","category":"page"},{"location":"repl/rendering/#jujutracer.ImageTracer","page":"Rendering","title":"jujutracer.ImageTracer","text":"struct ImageTracer\n\nConvenient struct to hold the hdrimage and the camera.\n\nFields\n\nimg::hdrimg: The HDR image to be traced.\ncamera::AbstractCamera: The camera used for tracing rays. Can be either Orthogonal or Perspective.\n\nConstructor\n\nImageTracer(): Creates a new ImageTracer with a default HDR image and an orthogonal camera.\nImageTracer(img::hdrimg, camera::AbstractCamera): Creates a new ImageTracer with the specified HDR image and camera.\n\nFunctional Usage\n\nImageTracer(fun::Function): tracing the image with fun renderer.\nImageTracer(fun::Function, AA::Int64, pcg::PCG): tracing the image with fun renderer and Anti-Aliasing method with AA^2 subdivision in the pixel.\n\n\n\n\n\n","category":"type"},{"location":"repl/rendering/#Saving","page":"Rendering","title":"Saving","text":"","category":"section"},{"location":"repl/rendering/","page":"Rendering","title":"Rendering","text":"jujutracer provides functions to save the rendered image boht in HDR and LDR formats.","category":"page"},{"location":"repl/rendering/#jujutracer.write_pfm_image","page":"Rendering","title":"jujutracer.write_pfm_image","text":"write_pfm_image(img::hdrimg, io, endianness::Bool=true)\n\nWrite a PFM file encodiding the content of an hdrimg\n\nArguments\n\nimg::hdrimg: The HDR image to be written to the PFM file.\nio::IO: The output stream to which the PFM image will be written.\nendianness::Bool: A boolean indicating whether to write the float values in little-endian format (default is true).\n\n\n\n\n\nwrite_pfm_image(img::hdrimg, filename::String, endianness::Bool=true)\n\nWrite a PFM file encoding the content of an hdrimg.\n\nArguments\n\nimg::hdrimg: The HDR image to be written to the PFM file.\nfilename::String: The file path where the PFM image will be saved, including the \".pfm\" extension.\nendianness::Bool: A boolean indicating whether to write the float values in little-endian format (default is true).\n\nRaises\n\nInvalidFileFormat: If the file extension is not \".pfm\".\n\n\n\n\n\n","category":"function"},{"location":"repl/rendering/#jujutracer.tone_mapping","page":"Rendering","title":"jujutracer.tone_mapping","text":"tone_mapping(img::hdrimg; a=0.18, lum = nothing, γ = 1.0)\n\nApply tone mapping to the HDR image.\n\nArguments\n\nimg::hdrimg: The HDR image to be tone-mapped.\na::Float64: A positive value to be used in the normalization formula (default is 0.18).\nlum::Float64: The average luminosity of the image. If not provided, it will be calculated using _average_luminosity.\nγ::Float64: The gamma value to be used for correction. Must be a positive number (default is 1.0).\n\nReturns\n\nhdrimg: The tone-mapped HDR image.\n\n\n\n\n\n","category":"function"},{"location":"repl/rendering/#jujutracer.get_matrix","page":"Rendering","title":"jujutracer.get_matrix","text":"get_matrix(img::hdrimg)\n\nExtract the matrix from an HDR image.\n\nArguments\n\nimg::hdrimg: The HDR image from which to extract the matrix.\n\nReturns\n\nMatrix: The matrix representation of the HDR image.\n\n\n\n\n\n","category":"function"},{"location":"repl/rendering/#jujutracer.save_ldrimage","page":"Rendering","title":"jujutracer.save_ldrimage","text":"save_ldrimage(img_matrix::Matrix, filename::String)\n\nSave an LDR image to a file.\n\nArguments\n\nimg_matrix::Matrix: The matrix representation of the image to be saved.\nfilename::String: The name of the file to save the image to, including the file extension (\".png\" or \".jpg\").\n\nReturns\n\nString: The path to the saved file.\n\nRaises\n\nArgumentError: If the file extension is not valid or if the image values are not clamped.\n\n\n\n\n\n","category":"function"},{"location":"repl/world/#World","page":"World","title":"World","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"To define a scene, you will need to place some shapes in the world. All shapes are a subtype of AbstractShape. Moreover, shapes which are considerer \"solid\" or \"closed\" are a subtype of AbstractSolid. In addition to standard shapes there are auxiliary shapes such as AABB and BVHShape which are used as acceleration structures.","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"Every shape needs a material and a transformation.","category":"page"},{"location":"repl/world/#Materials","page":"World","title":"Materials","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"Materials are defined in a concrete type:","category":"page"},{"location":"repl/world/#jujutracer.Material","page":"World","title":"jujutracer.Material","text":"struct Material\n\nFields\n\nEmition::AbstractPigment: the pigement with which the radiation is emitted.\nBRDF::AbstractBRDF: the BRDF of the material.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#Pigments","page":"World","title":"Pigments","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"The emission of the material can be defined as a pigment, which is a subtype of AbstractPigment. ","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"They are based on the ColorTypes.jl package, of which we use the RGB type.","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"There are three types of pigments:","category":"page"},{"location":"repl/world/#jujutracer.UniformPigment","page":"World","title":"jujutracer.UniformPigment","text":"UniformPigment()\n\nUniform Pigment for Shapes\n\nFields\n\ncolor::RBG the uniform color\n\nFunctional Usage\n\nUniformPigment(p::SurfacePoint) return the RGB associated to the (u, v) coordinates of the SurfacePoint\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.CheckeredPigment","page":"World","title":"jujutracer.CheckeredPigment","text":"CheckeredPigment(col::Int32, row::Int32, dark::RGB, bright::RGB)\n\nCheckered pigment for a Shape, subdiveded in row rows and col columns with alternate dark and bright color\n\nFields\n\ncol number of horizontal subdivisions\nrow number of vertical subdivisions\ndark color of the dark squares\nbright color of the bright squares\n\nFunctional Usage\n\nCheckeredPigment(p::SurfacePoint) return the RGB associated to the (u, v) coordinates of the SurfacePoint \n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.ImagePigment","page":"World","title":"jujutracer.ImagePigment","text":"ImagePigment(img::hdrimg)\n\nPrint the image img as pigment of the surface\n\nFields\n\nimg::hdrimg the image in hdr format\n\nFunctional Usage\n\nImagePigment(p::SurfacePoint) return the RGB of to the (u, v) coordinates of the SurfacePoint associated to the corresponding element of img\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#BRDFs","page":"World","title":"BRDFs","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"The BRDF of the material is defined as a subtype of AbstractBRDF. The available BRDFs are","category":"page"},{"location":"repl/world/#jujutracer.DiffusiveBRDF","page":"World","title":"jujutracer.DiffusiveBRDF","text":"DiffusiveBRDF(Pigment::AbstractPigment)\n\nDiffusive BRDF with reflective pigment Pigment.\n\nFields\n\nPigment::AbstractPigment: the pigment used for the BRDF.\n\nFunctional Usage\n\nDiffusiveBRDF(pcg::PCG, in_dir::Vec, p::Point, normal::Normal, depth::Int64) returns a Ray sampled with diffusion.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.SpecularBRDF","page":"World","title":"jujutracer.SpecularBRDF","text":"SpecularBRDF(Pigment::AbstractPigment)\n\nSpecular BRDF with reflective pigment Pigment.\n\nFields\n\nPigment::AbstractPigment: the pigment used for the BRDF.\n\nFunctional Usage\n\nSpecularBRDF(pcg::PCG, in_dir::Vec, p::Point, normal::Normal, depth::Int64) returns a Ray sampled with specular reflection. Can also be called withtout pcg.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/","page":"World","title":"World","text":"A complete material can be defined as follows:","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"mat = Material(\n    ImagePigment(\"asset/sky.pfm\"),\n    DiffuseBRDF(UniformPigment(RGB(0.1, 0.7, 0.3)))\n)","category":"page"},{"location":"repl/world/#Transformations","page":"World","title":"Transformations","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"Transformations are defined as a subtype of AbstractTransformation. They are structs thah hold a transformation matrix and its inverse for fast change of basis from world to local coordinates. The available transformations are:","category":"page"},{"location":"repl/world/#jujutracer.Transformation","page":"World","title":"jujutracer.Transformation","text":"struct Transformation <: AbstractTransformation\n\nRepresents a transformation in 3D space with homogeneous coordinates. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructors\n\nTransformation(): Creates an identity transformation where M and inv are both 4x4 identity matrices.\nTransformation(M::Matrix{Float64}, inv::Matrix{Float64}): Creates a transformation with the given M and inv matrices.\nTransformation(M::Matrix{Float64}, inv::Matrix{Float64}, unsafe::Unsafe): Creates a transformation with the given M and inv matrices, without veryfing the inputs.\n\nThrows an ArgumentError if:\n\nM or inv are not 4x4 matrices.\nThe last element of M or inv is not 1.0.\nM and inv are not inverses of each other.\n\nNotes\n\nThe M and inv matrices must satisfy the following conditions:\n\nBoth must be 4x4 matrices.\nThe last element of both matrices must be 1.0.\nThe product of M and inv must be approximately equal to the 4x4 identity matrix.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Translation","page":"World","title":"jujutracer.Translation","text":"struct Translation <: AbstractTransformation\n\nRepresents a translation in 3D space with homogeneous coordinates. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse transformation matrix.\n\nConstructors\n\nTranslation(dx::Float64, dy::Float64, dz::Float64):  Creates a Translation object with translation offsets dx, dy, and dz along the x, y, and z axes, respectively.\nTranslation(v::Vec): Creates a Translation object using a Vec object.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Rx","page":"World","title":"jujutracer.Rx","text":"struct Rx <: AbstractTransformation\n\nRepresents a rotation transformation around the x-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRx(θ): Creates an Rx instance for a given rotation θ (in radians).\n\nSee also\n\nRy: For rotation around the y-axis.\nRz: For rotation around the z-axis.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Ry","page":"World","title":"jujutracer.Ry","text":"struct Ry <: AbstractTransformation\n\nRepresents a rotation transformation around the y-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRy(θ): Creates an Ry instance for a given rotation θ (in radians).\n\nSee also\n\nRx: For rotation around the x-axis.\nRz: For rotation around the z-axis.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Rz","page":"World","title":"jujutracer.Rz","text":"struct Rz <: AbstractTransformation\n\nRepresents a rotation transformation around the z-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRz(θ): Creates an Rz instance for a given rotation θ (in radians).\n\nSee also\n\nRx: For rotation around the x-axis.\nRy: For rotation around the y-axis.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Scaling","page":"World","title":"jujutracer.Scaling","text":"struct Scaling <: AbstractTransformation\n\nRepresents a scaling transformation in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nScaling(x::Float64, y::Float64, z::Float64):   Creates aScalinginstance with scaling factorsx,y, andzalong the x, y, and z axes, respectively.   Throws anArgumentError` if any of the scaling factors are zero.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#Shapes","page":"World","title":"Shapes","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"Shapes are defined as a subtype of AbstractShape. There are two categories of shapes:, the ones that can be used in CSG operations and the ones that cannot, such as flat shapes.","category":"page"},{"location":"repl/world/#Water-tight-Shapes","page":"World","title":"Water-tight Shapes","text":"","category":"section"},{"location":"repl/world/#jujutracer.Sphere","page":"World","title":"jujutracer.Sphere","text":"struct Sphere <: AbstractSolid\n\nA sphere. Unit radius sphere centered at the origin. This structure is a subtype of AbstractSolid.\n\nFields\n\nt::Transformation: the transformation applied to the sphere.\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Box","page":"World","title":"jujutracer.Box","text":"struct Box <: AbstractSolid\n\nAn axis-aligned box (rectangular cuboid) defined by two opposite corners.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the box.\nP1::Point: One corner of the box (minimum x, y, z) in the Box's local coordinate system.\nP2::Point: The opposite corner of the box (maximum x, y, z) in the Box's local coordinate system.\nMat::Material: The material of the box.\n\nConstructors\n\nBox(): Creates a new box with default transformation and material.\nBox(P1::Point, P2::Point): Creates a new box with the specified corners and default transformation and material.\nBox(P1::Point, P2::Point, Mat::Material): Creates a new box with the specified corners and material.\nBox(Tr::AbstractTransformation): Creates a new box with the specified transformation and default material.\nBox(Tr::AbstractTransformation, P1::Point, P2::Point): Creates a new box with the specified transformation and corners.\nBox(Tr::AbstractTransformation, P1::Point, P2::Point, Mat::Material): Creates a new box with the specified transformation, corners, and material.\nBox(Mat::Material): Creates a new box with the default transformation and the specified material.\nBox(Tr::AbstractTransformation, Mat::Material): Creates a new box with the specified transformation and material.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Cone","page":"World","title":"jujutracer.Cone","text":"struct Cone <: AbstractSolid\n\nA cone of unitary radiuos and height resting on the xy plane. This structure is a subtype of AbstractSolid.\n\nFields\n\nTr::Transformation: the transformation applied to the sphere.\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Cylinder","page":"World","title":"jujutracer.Cylinder","text":"struct Cylinder <: AbstractSolid\n\nA cylinder of unitary radius and height centered in the origin. This structure is a subtype of AbstractSolid.\n\nFields\n\nTr::Transformation: the transformation applied to the sphere.\nMat::Material: the material of the shape\n\nConstructors\n\nCylinder(): Creates a new cylinder with default transformation and material.\nCylinder(Tr::AbstractTransformation): Creates a new cylinder with the specified transformation and default material.\nCylinder(Mat::Material): Creates a new cylinder with the default transformation and the specified material.\nCylinder(Tr::AbstractTransformation, Mat::Material): Creates a new cylinder with the specified transformation and material.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#CSG-Shapes","page":"World","title":"CSG Shapes","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"Set operations are defined as methods on the AbstractSolid` type. The available operations are:","category":"page"},{"location":"repl/world/#jujutracer.CSGUnion","page":"World","title":"jujutracer.CSGUnion","text":"struct CSGUnion <: AbstractSolid\n\nRepresents the union of two solid shapes.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the union.\nSh1::AbstractSolid, Sh2::AbstractSolid: The two solid shapes being united.\n\nSee also\n\nCSGDifference: Represents the difference of two solid shapes.\nCSGIntersection: Represents the intersection of two solid shapes.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.CSGIntersection","page":"World","title":"jujutracer.CSGIntersection","text":"struct CSGIntersection <: AbstractSolid\n\nRepresents the intersection of two solid shapes.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the intersection.\nSh1::AbstractSolid, Sh2::AbstractSolid: The two solid shapes being intersected.\n\nSee also\n\nCSGUnion: Represents the union of two solid shapes.\nCSGDifference: Represents the difference of two solid shapes.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.CSGDifference","page":"World","title":"jujutracer.CSGDifference","text":"struct CSGDifference <: AbstractSolid\n\nRepresents the difference of two solid shapes.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the difference.\nSh1::AbstractSolid, Sh2::AbstractSolid: The two solid shapes where Sh1 - Sh2 is computed.\n\nSee also\n\nCSGUnion: Represents the union of two solid shapes.\nCSGIntersection: Represents the intersection of two solid shapes.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#Flat-Shapes","page":"World","title":"Flat Shapes","text":"","category":"section"},{"location":"repl/world/#jujutracer.Plane","page":"World","title":"jujutracer.Plane","text":"struct Plane <: AbstractShape\n\nA plane. This structure is a subtype of AbstractShape.\n\nFields\n\nt::Transformation: the transformation applied to the plane\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Triangle","page":"World","title":"jujutracer.Triangle","text":"struct Triangle <: AbstractShape\n\nTriangle.\n\nFields\n\nt::Transformation: the transformation applied to the triangle\nA, B, C::Point: the vertices of the triangle\nMat::Material: the material of the shape\n\nConstructor\n\nTriangle(): creates a triangle with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nTriangle(Tr::AbstractTransformation): creates a triangle with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nTriangle(Mat::Material): creates a triangle with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nTriangle(Tr::AbstractTransformation, Mat::Material): creates a triangle with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nTriangle(A::Point, B::Point, C::Point): creates a triangle with Identity Transformation and vertices A, B, C and a default material.\nTriangle(A::Point, B::Point, C::Point, Mat::Material): creates a triangle with Identity Transformation and vertices A, B, C and a Mat material.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Parallelogram","page":"World","title":"jujutracer.Parallelogram","text":"struct Parallelogram <: AbstractShape\n\nParallelogram\n\n   C-----p\n  /     /\n /     /\nA-----B\n\nFields\n\nt::Transformation: the transformation applied to the Parallelogram.\nA, B, C::Point: the vertices defining the quadrilateral's \nMat::Material: the material of the shape\n\nConstructor\n\nParallelogram(): creates a parallelogram with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nParallelogram(Tr::AbstractTransformation): creates a parallelogram with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nParallelogram(Mat::Material): creates a parallelogram with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nParallelogram(Tr::AbstractTransformation, Mat::Material): creates a parallelogram with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nParallelogram(A::Point, B::Point, C::Point): creates a parallelogram with Identity Transformation and vertices A, B, C and a default material.\nParallelogram(A::Point, B::Point, C::Point, Mat::Material): creates a parallelogram with Identity Transformation and vertices A, B, C and a Mat material.\nParallelogram(A::Point, AB::Vec, AC::Vec): creates a parallelogram with Identity Transformation and vertices A, A + AB, A + AC and a default material.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Rectangle","page":"World","title":"jujutracer.Rectangle","text":"struct Rectangle <: AbstractShape\n\n1x1 Rectangle on xy plane, centered in the origin\n\nFields\n\nt::Transformation: the transformation applied to the plane\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.Circle","page":"World","title":"jujutracer.Circle","text":"struct Circle <: AbstractShape\n\nA unit circle in the xy-plane, centered at the origin.\n\nFields\n\nTr::AbstractTransformation: the transformation applied to the circle.\nMat::Material: the material of the shape.\n\nConstructors\n\nCircle(): Creates a new circle with default transformation and material.\nCircle(Tr::AbstractTransformation): Creates a new circle with the specified transformation and default material.\nCircle(Mat::Material): Creates a new circle with the default transformation and the specified material.\nCircle(Tr::AbstractTransformation, Mat::Material): Creates a new circle with the specified transformation and material.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#Meshes","page":"World","title":"Meshes","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"Meshes are defined as structs that hold a vector of triangles, a vector of points and the file from which the mesh was loaded.","category":"page"},{"location":"repl/world/#jujutracer.mesh","page":"World","title":"jujutracer.mesh","text":"struct mesh <: AbstractShape\n\nmesh.\n\nFields\n\nfile::String: the source file.obj of the mesh\nshape::Vector{Triangle}: the triangles of the mesh\n\nKeywords\n\norder::String: the order of the coordinates in the file, default is \"dwh\" (depth, width, height). If the order is different, you can specify it with this keyword argument.\n\nConstructor\n\nmesh(shapes::Vector{Triangle}): creates a mesh frome the Vector{Triangle}\nmesh(file::String): creates a mesh from file\nmesh(file::String, Tr::AbstractTransformation): creates a mesh from file with a transformation Tr \nmesh(file::String, Mat::Material): creates a mesh with Mat material from file\nmesh(file::String, Tr::AbstractTransformation, Mat::Material): creates a mesh with Tr transformation and a Mat material.\n\nFor all constructors from obj files, the order of the coordinates in the file is assumed to be \"dwh\" (depth, width, height) by default. If the order is different, you can specify it with the order keyword argument.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.read_obj_file","page":"World","title":"jujutracer.read_obj_file","text":"read_obj_file(io::IOBuffer; Tr::AbstractTransformation = Transformation(), Mat::Material = Material(); order = \"dwh\")\n\nMethod for constructing vectors and points from a buffer.\n\nFields\n\nio::IOBuffer: the buffer\nTr::AbstractTransformation: an hypotetical transformation to be applied to all the shapes and points\nMat::Material: an hypotetical material to be applied to all the triangles\n\nKeywords\n\norder::String: the order of the coordinates in the file, default is \"dwh\" (depth, width, height).\n\nReturns\n\nshape::Vector{Triangle}\npoints:Vector{Points}\n\n\n\n\n\nread_obj_file(io::IOBuffer; Tr::AbstractTransformation = Transformation(), Mat::Material = Material(); order = \"dwh\")\n\nMethod for constructing vectors and points from a file\n\nFields\n\nfilename::String: the name of the file.obj\nTr::AbstractTransformation: an hypotetical transformation to be applied to all the shapes and points\nMat::Material: an hypotetical material to be applied to all the triangles\n\nKeywords\n\norder::String: the order of the coordinates in the file, default is \"dwh\" (depth, width, height).\n\nReturns\n\nshape::Vector{Triangle}\npoints:Vector{Points}\n\n\n\n\n\n","category":"function"},{"location":"repl/world/#jujutracer.trianglize","page":"World","title":"jujutracer.trianglize","text":"trianglize(P::Vector{Points}, Tr::AbstractTransformation, Mat::Material)\n\nTriangulation method, working only with ordered verteces\n\nArguments\n\nP::Vector{Point}: the vector of points to be triangulated\nTr::AbstractTransformation: an hypotetical transformation to be applied to all the shapes and points\nMat::Material: a material to be applied to all the triangles\n\nReturns\n\ntr::Vector{Triangle}: a vector of triangles created from the points in P\n\n\n\n\n\n","category":"function"},{"location":"repl/world/#Acceleration-Structures","page":"World","title":"Acceleration Structures","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"Acceleration structures are used to speed up the ray tracing process by reducing the number of intersection tests.","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"The most basic acceleration structure is the AABB, which is an axis-aligned bounding box that contains a shape. It is used to quickly eliminate shapes that are not intersected by a ray.","category":"page"},{"location":"repl/world/#jujutracer.AABB","page":"World","title":"jujutracer.AABB","text":"struct AABB <: AbstractShape\n\nAxis-Aligned Bounding Box (AABB) for a set of shapes.\n\nFields\n\nS::Vector{AbstractShape}: the vector of shapes contained within the AABB.\nP1::Point: the minimum corner of the AABB.\nP2::Point: the maximum corner of the AABB.\n\nConstructor\n\nAABB(S::Vector{AbstractShape}): creates an AABB for the shapes in S, calculating the minimum and maximum corners based on the bounding boxes of the shapes.\nAABB(S::Vector{AbstractShape}, P1::Point, P2::Point): creates an AABB with the specified minimum and maximum corners P1 and P2 for the shapes in S.\nAABB(csg::Union{CSGDifference, CSGUnion, CSGIntersection}): creates an AABB for a CSG shape, extracting the shapes and their bounding box.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/","page":"World","title":"World","text":"Otherwise, jujutracer provides the means to build a binary tree of shapes using Boundary Volume Hierarchy (BVH) algorithm. The BVH is a tree structure that allows to quickly find the closest intersection between a ray and a shape. The BVH is built from a vector of shapes, which wil be divided into nodes with two possible methods:","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"simple: the shapes are divided into two groups based on their centroids\nsurface area heuristic (SAH): the shapes are divided into two groups based on their surface area, which is a more efficient method.","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"After that, the BVH is held in a BVHShape, which is a subtype of AbstractShape.","category":"page"},{"location":"repl/world/#jujutracer.BuildBVH!","page":"World","title":"jujutracer.BuildBVH!","text":"BuildBVH!(shapes::Vector{AbstractShape}; use_sah::Bool=false, max_shapes_per_leaf::Int64=2, n_buckets::Int64=12)\n\nBuild a Boundary Volume Hierarchy (BVH) tree from a vector of shapes.\n\nArguments\n\nshapes::Vector{AbstractShape}: The vector of shapes to build the BVH from. Note: it will be modified in place.\n\nKeyword Arguments\n\nuse_sah::Bool=false: Whether to use the Surface Area Heuristic (SAH) for subdivision.\nmax_shapes_per_leaf::Int64=2: The maximum number of shapes allowed in a leaf node.\nn_buckets::Int64=12: The number of buckets to use for SAH.\n\nReturns\n\n(BVHNode, Int64): A tuple containing the root node of the BVH tree and the maximum depth of the tree.\n\n\n\n\n\n","category":"function"},{"location":"repl/world/#jujutracer.Subdivide!","page":"World","title":"jujutracer.Subdivide!","text":"Subdivide!(node::BVHNode, shapes::Vector{AbstractShape}, centroids::Vector{Point}, depth::Int64; max_shapes_per_leaf::Int64=2)\n\nSubdivide a BVH node into left and right child nodes based on the centroids of the shapes. Recursive method.\n\nArguments\n\nnode::BVHNode: The BVH node to subdivide.\nshapes::Vector{AbstractShape}: The vector of shapes used by the BVH Tree. Note: it will be modified in place.\ncentroids::Vector{Point}: The centroids of the shapes.\ndepth::Int64: The current depth of the BVH tree.\n\nKeyword Arguments\n\nmax_shapes_per_leaf::Int64=2: The maximum number of shapes allowed in a leaf node.\n\nReturns\n\nInt64: The maximum depth of the BVH tree after subdivision.\n\n\n\n\n\n","category":"function"},{"location":"repl/world/#jujutracer.SubdivideSAH!","page":"World","title":"jujutracer.SubdivideSAH!","text":"SubdivideSAH!(node::BVHNode, shapes::Vector{AbstractShape}, centroids::Vector{Point}, depth::Int64; max_shapes_per_leaf::Int64=2, n_buckets::Int64=12)\n\nSubdivide a BVH node using the Surface Area Heuristic (SAH) method. Recursive method.\n\nArguments\n\nnode::BVHNode: The BVH node to subdivide.\nshapes::Vector{AbstractShape}: The vector of shapes used by the BVH Tree. Note: it will be modified in place.\ncentroids::Vector{Point}: The centroids of the shapes.\ndepth::Int64: The current depth of the BVH tree.\n\nKeyword Arguments\n\nmax_shapes_per_leaf::Int64=2: The maximum number of shapes allowed in a leaf node.\nn_buckets::Int64=12: The number of buckets to use for SAH.\n\nReturns\n\nInt64: The maximum depth of the BVH tree after subdivision.\n\n\n\n\n\n","category":"function"},{"location":"repl/world/#jujutracer.BVHShape","page":"World","title":"jujutracer.BVHShape","text":"struct BVHShape <: AbstractShape\n\nShape that holds a BVH tree and the relative shapes.\n\nFields\n\nbvhroot::BVHNode: The root node of the BVH tree.\nshapes::Vector{AbstractShape}: The vector of shapes used by the BVH Tree.\n\nConstructor\n\nBVHShape(bvhroot::BVHNode, shapes::Vector{AbstractShape}): Creates a new BVHShape with the specified BVH root and shapes.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/","page":"World","title":"World","text":"caution: BVHs and large shapes\nWhen using BVHs, and in particular when using the SAH method, adding to the accelerated shapes a large shape which cointains other shapes (such as a box or a sphere used as sky) can lead to a large leaf node, when the first split occurs. This can lead to a very slow rendering time, as the ray tracing algorithm will have to check every shape in the leaf node for intersection.","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"An example of using a BVH is when accelerating a mesh object:","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"m_tree = mesh(\"asset/tree.obj\"; order = \"whd\") # Beware that the mesh holds triangles, and not AbstractShapes.\n\nshapes = Vector{AbstractShape}()\nfor t in m_tree.shapes\n    push!(shapes, t)\nend\n\nbvh, bvhdepth = BuildBVH!(shapes; use_sah=true) # Returns the root node of the BVH and its depth.\n# `shapes` is rearranged according to the BVH intersection order.\nbvhshape = BVHShape(bvh, shapes)","category":"page"},{"location":"repl/world/#Light-Sources","page":"World","title":"Light Sources","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"Light sources are defined as a subtype of AbstractLight. They are used to illuminate the scene.","category":"page"},{"location":"repl/world/#jujutracer.LightSource","page":"World","title":"jujutracer.LightSource","text":"struct LightSource\n\nA struct representing a point light source.\n\nFields\n\nposition::Point: the position of the light source in 3D space.\nemission::RGB: the color of the light emitted by the source.\nscale::Float64: the scale factor for the light source, affecting its intensity.\n\nConstructors\n\nLightSource(position::Point, emission::RGB=RGB(1.0, 1.0, 1.0), scale::Float64=1.0): Creates a new light source with the specified position, emission color, and scale factor.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#jujutracer.SpotLight","page":"World","title":"jujutracer.SpotLight","text":"struct SpotLight <: AbstractLight\n\nA struct representing a spotlight source.\n\nFields\n\nposition::Point: the position of the spotlight in 3D space.\ndirection::Vec: the direction in which the spotlight is pointing.\nemission::RGB: the color of the light emitted by the spotlight.\nscale::Float64: the scale factor for the spotlight, affecting its intensity.\ncos_total::Float64: the cosine of the angle that defines the total light cone.\ncos_falloff::Float64: the cosine of the angle that defines the falloff region of the spotlight.\n\nConstructors\n\nSpotLight(position::Point, direction::Vec, emission::RGB=RGB(1.0, 1.0, 1.0), scale::Float64=100.0, cos_total::Float64=0.9, cos_falloff::Float64=0.93): Creates a new spotlight with the specified parameters.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/#World-2","page":"World","title":"World","text":"","category":"section"},{"location":"repl/world/","page":"World","title":"World","text":"Once the shapes are defined (and lights), they can be added to the world. A vector of shapes and lights need to be prepared, from which the world will be created.","category":"page"},{"location":"repl/world/#jujutracer.World","page":"World","title":"jujutracer.World","text":"struct World\n\nA struct representing a collection of shapes (and lights) in a 3D world.\n\nFields\n\nshapes::Vector{AbstractShape}: the vector containing the shapes in the world.\nlights::Vector{AbstractLight}: the vector containing the light sources in the world.\n\nConstructor\n\nWorld(): creates a new World with an empty vector of shapes.\nWorld(S::Vector{AbstractShape}): creates a new World with the specified vector of shapes. Lights are initialized to an empty vector.\nWorld(S::Vector{AbstractShape}, L::Vector{AbstractLight}): creates a new World with the specified vector of shapes and light sources.\n\nSee also\n\nAbstractShape: the abstract type for all shapes.\nSphere: a concrete implementation of AbstractShape representing a sphere.\nPlane: a concrete implementation of AbstractShape representing a plane.\n\n\n\n\n\n","category":"type"},{"location":"repl/world/","page":"World","title":"World","text":"An example of creating a world is as follows:","category":"page"},{"location":"repl/world/","page":"World","title":"World","text":"shapes = Vector{AbstractShape}()\nlights = Vector{AbstractLight}()\n\npush!(shapes, sphere)\npush!(shapes, ground)\npush!(lights, light1)\npush!(lights, spot1)\n\nworld = World(shapes, lights)","category":"page"},{"location":"scene/scene_usage/#Scene-Usage","page":"Scene Usage","title":"Scene Usage","text":"","category":"section"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"jujutracer provides all the necessary pieces to interpret a scene.txt file, and is able to parse the construction of the desired scene.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"The rendering of the scene is not completly yield from the scene file: the type of renderer, the image resolution, the antialiasing and other parameters are specified at the time of execution. These instructions are provided in the Interpreter section.","category":"page"},{"location":"scene/scene_usage/#Scene-Definition-Language","page":"Scene Usage","title":"Scene Definition Language","text":"","category":"section"},{"location":"scene/scene_usage/#Float-variables","page":"Scene Usage","title":"Float variables","text":"","category":"section"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Float variables are used to define some constants that can be used in the scene.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"They are defined by calling the keyword float followed by the name of the variable and the value between parenthesis.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"float name({value})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"For example, to define the value of pi:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"float pi(3.141592653589793)","category":"page"},{"location":"scene/scene_usage/#Materials","page":"Scene Usage","title":"Materials","text":"","category":"section"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Materials are defined by the keyword material followed by the name of the material, and enclosed in parenthesis the definition of the BRDF and the emission pigment.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Pigments are used to define a texture. The most basic types of pigments are uniform and checkered. They are based on colors, which are defined as follow a triplet of floats:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"< r, g, b >","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Where r, g and b are the red, green and blue components of the color, respectively. Previously defined float variables can be used to define the color, for example:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"< pi, 0.5, 0.2 >","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"A uniform pigment is defined with the keyword uniform followed by the color:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"uniform({color})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"While a checkered pigment is defined with the keyword checkered followed by two colors and the number of subdivisions:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"checkered({color1}, {color2}, {n_subdivisions})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"And finally there is the image pigment, which is used to load an image from a file. It is defined with the keyword image followed by the path to the image file:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"image(\"path/to/image.pfm\")","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"BRDF are used to define the interaction of the light with the material. The most basic type of BRDF is diffuse, which is defined with the keyword diffuse followed by a pigment:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"diffuse({pigment})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"And there is also the specular BRDF, which is defined with the keyword specular followed by a pigment:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"specular({pigment})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Materials are to be declared as variables, which will be used in the definition of the shapes. The syntax is done with the keyword material followed by the name of the material, and enclosed in parenthesis the definition of the BRDF and the emission pigment:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"material mat_name(\n    {brdf},\n    {emission_pigment}\n)","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Some examples of materials:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"material ground_material(\n    diffuse(checkered(<0.3, 0.5, 0.1>,\n                      <0.1, 0.2, 0.5>, 4)),\n    uniform(<0, 0, 0>)\n)\n\nmaterial sphere_material(\n    specular(uniform(<0.5, 0.5, 0.5>)),\n    uniform(<0, 0, 0>)\n)\n\nmaterial sky_material(\n    diffuse(image(\"asset/sky.pfm\")),\n    uniform(<0, 0, 0>)\n)","category":"page"},{"location":"scene/scene_usage/#Transformations","page":"Scene Usage","title":"Transformations","text":"","category":"section"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Transformations are used both in shapes definitions and to orient the camera.  The supported transformations are defined with the keywords identity, translation, rotation_x, rotation_y, rotation_z and scaling. They are defined as follows:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"identity\ntranslation([x, y, z])\nrotation_x(angle)\nrotation_y(angle)\nrotation_z(angle)\nscaling([x, y, z])","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Where angle is in radians and [x, y, z] are the components of the vector. Previously defined float variables can be used to define the angle or the vector values.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"They can be combined together by using the * operator, which is the composition of the transformations. For example, to rotate an object around the x-axis and then translate it:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"float angle(30.0)\n\n...\n\nrotation_x(angle) * translation([1, 0, 0])","category":"page"},{"location":"scene/scene_usage/#Shapes","page":"Scene Usage","title":"Shapes","text":"","category":"section"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Shapes are defined similar to materials. They are define by applying the keyword corresponding to the type of shape, followed by the name of the shape and enclosed in parenthesis the material and the transformation, or in some cases the parameters of the shape.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"sphere({material_name}, {transformation})\nbox({material_name}, {transformation})\ncylinder({material_name}, {transformation})\ncone({material_name}, {transformation})\nplane({material_name}, {transformation})\ncircle({material_name}, {transformation})\nrectangle({material_name}, {transformation})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Other shapes are to be defined with additional parameters.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"triangle({material_name}, {v1}, {v2}, {v3})\nparallelogram({material_name}, {v1}, {v2}, {v3})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Where {v1}, {v2} and {v3} are the vertices of the triangle or parallelogram, defined as the vector [x, y, z].","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Some examples of shapes:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"sphere sphere1(\n    sphere_material,\n    translation([0, 0, 0]) * scaling([0.5, 0.5, 0.5])\n)\n\nbox box1(\n    ground_material,\n    translation([0, -0.5, 0]) * scaling([2, 0.5, 2])\n)\n\ntriangle triangle1(\n    sphere_material,\n    [0, 0, 0],\n    [1, 0, 0],\n    [0, 1, 0]\n)","category":"page"},{"location":"scene/scene_usage/#CSG-Shapes","page":"Scene Usage","title":"CSG Shapes","text":"","category":"section"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"CSG (Constructive Solid Geometry) shapes are defined by combining other shapes using boolean operations. As per shapes, they are defined by applying the keyword corresponding to the type of CSG shape, followed by the name of the shape and enclosed in parenthesis transformation, first shape and second shape. The shapes used must be water-tight.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"The supported CSG shapes are union, intersection and difference:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"union name({transformation}, {shape1}, {shape2})`\ndifference name({transformation}, {shape1}, {shape2})`\nintersection name({transformation}, {shape1}, {shape2})`","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Where {shape1} and {shape2} are the names of the shapes to be combined, and can be other CSG shapes. Shapes need to be defined before the CSG shapes.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Some examples of CSG shapes:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"union union1(\n    translation([0, 0, 0]) * scaling([0.5, 0.5, 0.5]),\n    sphere1,\n    box1\n)\ndifference difference1(\n    translation([0, 0, 0]) * scaling([0.5, 0.5, 0.5]),\n    sphere1,\n    box1\n)\nintersection intersection1(\n    translation([0, 0, 0]) * scaling([0.5, 0.5, 0.5]),\n    sphere1,\n    box1\n)\n\nunion union2(\n    translation([0, 0, 0]) * scaling([0.5, 0.5, 0.5]),\n    union1,\n    difference1\n)","category":"page"},{"location":"scene/scene_usage/#Meshes","page":"Scene Usage","title":"Meshes","text":"","category":"section"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"External models in the OBJ format can be loaded as meshes. They are defined with the keyword mesh followed by the name of the mesh, and in parenthesis the name of the material to be used, the transformation to be applied to the mesh, the filename of the mesh and the expected order for the coordinates.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"mesh({material_name}, {transformation}, {filename}, {order})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Where {filename} is a string defined as \"path/to/mesh.obj\". The last parameter {order} is a string that defines the order of the coordinates in the OBJ file, which define the coordinates of the vertices. The expected format is a succesion of d, w and h, where d stands for depth, w for width and h for height. For example, if the OBJ file has the coordinates in the order [x, y, z], the order is \"dwh\". If the coordinates are in the order [x, z, y], the order is \"whd\"","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Some examples of meshes:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"mesh tree(mat_tree, translation([-5.0, 0.0, -0.05]) * scaling([tree_scale, tree_scale, tree_scale]), \"asset/tree.obj\", \"whd\")\nmesh m1(mat_box, translation([1.5, 2.5, 0.0]) * scaling([0.1, 0.1, 0.1]) * translation([0.0, 0.0, -3.05]), \"humanoid_tri.obj\", \"dwh\")","category":"page"},{"location":"scene/scene_usage/#Lights","page":"Scene Usage","title":"Lights","text":"","category":"section"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Point-like lights are used in the Point Light Tracing renderer.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Point lights are defined with the keyword pointlight followed by the name of the light, the position of the light and the color of the light. The position is defined as a vector [x, y, z] and the color as a triplet of floats <r, g, b>.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"pointlight name([x, y, z], {color}, {scale_factor})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Spotlights are defined with the keyword spotlight followed by the name of the light, the position of the light, the direction of the light, the color of the light, the angle of the cone of light, the falloff angle, and finally the scale factor.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"spotlight name([x, y, z], [dx, dy, dz], {color}, {angle}, {falloff_angle}, {scale_factor})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Where [dx, dy, dz] is the direction of the light.","category":"page"},{"location":"scene/scene_usage/#World-and-camera","page":"Scene Usage","title":"World and camera","text":"","category":"section"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Once the shapes have been defined, they need to be added to the world. Shapes are added with the keyword add followed by the name of the shape.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"add sphere1\nadd box1\nadd union2","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"Also lights need to be added to the world, with the same keyword add followed by the name of the light:","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"add pointlight1\nadd spotlight1","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"note: CSG and Meshes\nUnder the hood, some shapes are automatically boxed into acceleration structures:CSG shapes are boxed into an AABB.\nmesh constituents are boxed into the same BVH.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"And last, but not the least, a camera needs to be defined. The camera is defined with the keyword camera followed by the type of camera, the transformation to be applied to the camera, and the aspect ratio. The type of camera can be either perspective or orthogonal. The perspective camera also requires a screen distance.","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"# perspective\ncamera(perspective, {tranformation}, {aspect_ratio}, {screen_distance})\n# orthogonal\ncamera(orthogonal, {tranformation}, {aspect_ratio})","category":"page"},{"location":"scene/scene_usage/","page":"Scene Usage","title":"Scene Usage","text":"{aspect_ratio} and {screen_distance} are both float variables.","category":"page"},{"location":"introduction/#Overall","page":"Overall","title":"Overall","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"The jujutracer module allows creating 3D scenes by following a well defined physical model. It is based on a ray tracing algorithm that simulates the interaction of light with objects in a scene.","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"The intersection of rays with objects is the core of the rendering process. A full geometry framework is provided as the basis for the instersection logic, which handles all the transformation from the local coordinates of the shapes to the world coordinates, and vice versa.","category":"page"},{"location":"introduction/#Shapes","page":"Overall","title":"Shapes","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"All shapes are defined as objects which hold a material and a transformation. The material defines the appearance of the shape, while the transformation defines its position and orientation in the scene. The following shapes are supported:","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"plane\nsphere\nbox\ncone\ncylinder\ntriangle\nparallelogram\nrectangle\ncircle\nmesh (of triangles)","category":"page"},{"location":"introduction/#Costructive-Solid-Geometry-(CSG)","page":"Overall","title":"Costructive Solid Geometry (CSG)","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"Jujutracer supports Constructive Solid Geometry (CSG) operations, which allow combining shapes using set operations: union, intersection, and difference. CSG can be applied only to water-tight shapes, which are:","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"sphere\nbox\ncone\ncylinder","category":"page"},{"location":"introduction/#Materials","page":"Overall","title":"Materials","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"Materials defines how a ray interacts with a shape. Materials can be emissive, and the interaction modeled by the material's surface is defined by a BRDF (Bidirectional Reflectance Distribution Function). Both emission and BRDF are defined upon pigments, which define the material's texture.","category":"page"},{"location":"introduction/#BRDFs","page":"Overall","title":"BRDFs","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"In jujutracer, there are two brdf types:","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"diffuse: This type of BRDF models a surface that scatters light uniformly in all directions.\nspecular: This type of BRDF models a surface that reflects light as a perfect mirror.","category":"page"},{"location":"introduction/#Pigments","page":"Overall","title":"Pigments","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"In jujutracer, pigments are used both in the emission and in the BRDF. There are three types of pigments:","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"uniform: This pigment defines a constant color.\ncheckered: This pigment defines a checkered pattern with two colors.\nimage: This pigment defines a texture loaded from an image file.","category":"page"},{"location":"introduction/#Transformations","page":"Overall","title":"Transformations","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"Transformations are used to position and orient shapes in the scene. Jujutracer provides the following transformations (and their combinations):","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"identity: The identity transformation, which does not change the shape.\ntranslation: Moves a shape by a specified vector.\nrotation: Rotates a shape around an axis.\nscaling: Scales a shape by a specified factor.","category":"page"},{"location":"introduction/#Camera","page":"Overall","title":"Camera","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"The camera is defined by its position, a transformation, a distance to the focal plane, and the aspect ratio. Jujutracer supports two types of cameras:","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"perspective: This camera represent a perspective projection.\northogonal: This camera represents an orthoghonal projection.","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"Rays are fired from the camera's position towards the scene.","category":"page"},{"location":"introduction/#Light-sources","page":"Overall","title":"Light sources","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"As per the physical model, light sources are defined as objects that emit light. That is, every object with an emissive pigment is a light source. However, jujutracer provides point-light sources used in partcular rendering algorithm. These point-light sources are:","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"point light: A point light source emits light uniformly in all directions from a single point.\nspot light: A spot light source emits light as a cone from a single point.","category":"page"},{"location":"introduction/#Renderer","page":"Overall","title":"Renderer","text":"","category":"section"},{"location":"introduction/","page":"Overall","title":"Overall","text":"The renderer is responsible for rendering the scene by firing rays from the camera and trace them through every intersection. Jujutracer provides several rendering algorithms:","category":"page"},{"location":"introduction/","page":"Overall","title":"Overall","text":"on off renderer: This renderer simply checks if a ray intersects with an object and returns the same color for every intersection. It is the simplest rendering algorithm.\nflat renderer: This renderer returns the combination of the emissive pigment and the BRDF pigment of the first intersection. \npath tracer: This renderer is based on the path tracing algorithm, which leverages monte carlo integration to sample diffusion and reflection of light in the scene. It is the most advanced rendering algorithm, and it can produce realistic images by accounting for emission and reflection of light in the scene.\npoint light tracer: This renderer is based on the point light tracing algorithm, which traces rays from the camera to the (point) light sources in the scene. It is a simplified version of the path tracer, it does not account sample light diffusion but approximates it.","category":"page"},{"location":"scene/interpreter/#Interpreter","page":"Interpreter","title":"Interpreter","text":"","category":"section"},{"location":"scene/interpreter/","page":"Interpreter","title":"Interpreter","text":"Once a scene is defined in a text file such as scene.txt, it can be interpreted and rendered using the interpreter.jl script. This script is designed to read the scene file, parse its contents, and execute the rendering process based on the specified parameters.","category":"page"},{"location":"scene/interpreter/","page":"Interpreter","title":"Interpreter","text":"Parameters available are:","category":"page"},{"location":"scene/interpreter/","page":"Interpreter","title":"Interpreter","text":"Parameter Keyword(s) Default Value Description\nImage Width --width, -W 640 Width of the output image\nImage Height --height, -H round(width / camera.a_ratio) Height of the output image\nOutput Image --output, -o <scene_filename>_<renderer>_<width>x<height>.png Output image file name\nOutput PFM --pfm_output, -p <scene_filename>_<renderer>_<width>x<height>.pfm Output PFM file name\nRenderer --renderer, -r path_tracer Rendering algorithm\nAntialiasing --antialiasing, -a 2 Antialiasing level\nRays per Hit --n_rays 3 Rays fired at each intersection\nMax Ray Depth --depth 3 Maximum ray recursion depth\nRussian Roulette --russian 2 Russian roulette level\nOverriden Variables -v [var1 1.0...] None Override scene variables\nSeed for PCG --seed 42 Seed for the random number generator\nSequence number for PCG --sequence 54 Unique sequence identifier for the RNG","category":"page"},{"location":"scene/interpreter/","page":"Interpreter","title":"Interpreter","text":"The name of the scene file must be provided as the first argument when running the script. All other parameters are optional and will use their default values if not specified.","category":"page"},{"location":"scene/interpreter/","page":"Interpreter","title":"Interpreter","text":"The final usage of the script is:","category":"page"},{"location":"scene/interpreter/","page":"Interpreter","title":"Interpreter","text":"julia -t auto interpreter.jl scene.txt","category":"page"},{"location":"scene/interpreter/","page":"Interpreter","title":"Interpreter","text":"Another example of usage with custom parameters:","category":"page"},{"location":"scene/interpreter/","page":"Interpreter","title":"Interpreter","text":"julia -t 4 .\\interpreter.jl .\\scenes\\tree.txt -W 900 -H 1600 -a 4 --n_rays 4 --depth 3 -o .\\Images\\tree_path_1600x900_4_4_3_2.png -p .\\Images\\tree_path_900x1600_4_4_3_2.pfm","category":"page"},{"location":"repl/repl_examples/#REPL-Examples","page":"REPL Examples","title":"REPL Examples","text":"","category":"section"},{"location":"repl/repl_examples/#First-Demo","page":"REPL Examples","title":"First Demo","text":"","category":"section"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"A demo scene is provided with the demo.jl script. The scene is composed by 8 spheres with a uniform pigment positioned on the edges of a cube, and 2 checkered spheres placed in the middle of two adiacent faces. The user must provide the output filename, which will be used to saved the output image in both .pfm and .png formats, the width and height of the image and the camera angle.","category":"page"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"julia demo.jl <output_file> <width> <height> <cam_angle>","category":"page"},{"location":"repl/repl_examples/#CSG-Demo","page":"REPL Examples","title":"CSG Demo","text":"","category":"section"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"A demo scene is provided for showcasing Constructive Solid Geometry capabilities. demoCSG.jl provides a perspective view of a few operations between 2 spheres and a cone: union between 3 shapes, union of 2 spheres from which is substracted the cone, and finally the intersection of all 3 shapes. Rotations are applied to the CSG shapes.","category":"page"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"Usage of the script is similar to demo.jl:","category":"page"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"julia demoCSG.jl <output_file> <width> <height> <cam_angle>","category":"page"},{"location":"repl/repl_examples/#Demo-Path","page":"REPL Examples","title":"Demo Path","text":"","category":"section"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"A demo scene is provided for showcasing the path-tracer algorithm implemented with demoPath.jl. The scene is composed by a checkered diffusive plane used as a floor, which cut in half a reflective red sphere. Hovering the floor there is a checkered diffusive sphere, and a bright sky is provided.","category":"page"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"Usage of the script is the same:","category":"page"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"julia demoPath.jl <output_file> <width> <height> <cam_angle>","category":"page"},{"location":"repl/repl_examples/#Demo-All","page":"REPL Examples","title":"Demo All","text":"","category":"section"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"A demo script implmenting CSGs, AABBs, meshes, and flat shape is provided with demoAll.jl. The script can be modified with the preferred method of rendering, resolution, antialiasing and path tracing parameters. With \"depth\" renderer a BVH tree is implemented.","category":"page"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"The usage of the script is:","category":"page"},{"location":"repl/repl_examples/","page":"REPL Examples","title":"REPL Examples","text":"julia demoAll.jl","category":"page"},{"location":"#jujutracer","page":"jujutracer","title":"jujutracer","text":"","category":"section"},{"location":"","page":"jujutracer","title":"jujutracer","text":"","category":"page"},{"location":"","page":"jujutracer","title":"jujutracer","text":"jujutracer is a simple ray tracer written in Julia. The code has been written alongside the lessons held for the Calcolo Numerico per la Generazione di Immagini Fotorealistiche during the 2024 -2023 academic year @ UNIMI. The goal of this project is to provide the necessary framework to render photorealistic images based on radiometric principles, with also a basic language to define the scene to be rendered.","category":"page"},{"location":"#Contents","page":"jujutracer","title":"Contents","text":"","category":"section"},{"location":"","page":"jujutracer","title":"jujutracer","text":"Pages = [\n    \"index.md\",\n    \"introduction.md\",\n    ]","category":"page"},{"location":"","page":"jujutracer","title":"jujutracer","text":"Pages = Main.SCENE_USAGE_SUBSECTION\nDepth = 5","category":"page"},{"location":"","page":"jujutracer","title":"jujutracer","text":"Pages = Main.REPL_USAGE_SUBSECTION\nDepth = 5","category":"page"},{"location":"repl/repl_usage/#REPL-Usage","page":"REPL Usage","title":"REPL Usage","text":"","category":"section"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"jujutracer exposes various function and structs that can be used in the repl to create scenes, render them and save the results.","category":"page"},{"location":"repl/repl_usage/#Quick-Start","page":"REPL Usage","title":"Quick Start","text":"","category":"section"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"A quick start to create a scene and render it is as follows:","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"julia -t auto","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"using Pkg\nPkg.activate(\".\")\nusing jujutracer","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"Create some shapes. They must have materials and transfomations defined. A material can be defined as emissive or not by defining its color, and with a diffusive or mirror-like behavior.","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"mat_ground = Material(UniformPigment(RGB(0.0, 0.0, 0.0)), DiffusiveBRDF(CheckeredPigment(RGB(0.1, 0.1, 0.1), RGB(0.2, 0.2, 0.2), 8, 8)))\nmat_sphere = Material(UniformPigment(RGB(0.0, 0.0, 0.0)), SpecularBRDF(UniformPigment(RGB(1.0, 1.0, 1.0))))\nmat_sky = Material(ImagePigment(\"asset/sky.pfm\"), DiffusiveBRDF(UniformPigment(RGB(0.1, 0.1, 0.1))))\n\nground = Plane(mat_ground)\nsphere = Sphere(mat_sphere, Scaling(0.5, 0.5, 0.5))\nsky = Sphere(mat_sky, Scaling(10.0, 10.0, 10.0))","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"Prepare the world with the shapes.","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"shapes = Vector{AbstractShape}()\npush!(shapes, ground)\npush!(shapes, sphere)\n\nworld = World(shapes)","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"Action! Create a camera and a renderer.","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"# Prepare the hdr image\nhdrimage = HDRImage(800, 600)\n# Set the camera\ncam = Perspective(d=2.0, t=(-1.5, 0.0, 1.0) ⊙ Ry(-π / 10.0))\n# Prepare the renderer\nImgTr = ImageTracer(hdr, cam)\npcg = PCG()\npath = PathTracer(world, gray, pcg, 2, 5, 2)\n# Start the rendering\nImgTr(path, pcg)","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"Save the result. ","category":"page"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"# Save the HDR image\nwrite_pfm_image(hdr, pfm_output)\n# Save the LDR image\ntoned_img = tone_mapping(hdr; a=0.5, lum=0.5, γ=1.3)\nsave_ldrimage(get_matrix(toned_img), png_output)","category":"page"},{"location":"repl/repl_usage/#Contents","page":"REPL Usage","title":"Contents","text":"","category":"section"},{"location":"repl/repl_usage/","page":"REPL Usage","title":"REPL Usage","text":"Pages = Main.SCENE_USAGE_SUBSECTION\nDepth = 5","category":"page"}]
}
