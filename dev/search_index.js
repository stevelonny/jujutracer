var documenterSearchIndex = {"docs":
[{"location":"#jujutracer-documentation","page":"Home","title":"jujutracer documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the package jujutracer.","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert a PFM file into a LDR format such as .png or .jpg. Need a and gamma values specified.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia main.jl <pfm_file> <a> <gamma> <output_file>","category":"page"},{"location":"#Module-Index","page":"Home","title":"Module Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [jujutracer]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"#Detailed-API","page":"Home","title":"Detailed API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [jujutracer]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"#jujutracer.AbstractTransformation","page":"Home","title":"jujutracer.AbstractTransformation","text":"AbstractTransformation\n\nAn abstract type that serves as a base for defining various geometric transformations. Made concrete by Transformation, Translation, Scaling, Rx, Ry, and Rz.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.AbstractTransformation-Tuple{Normal}","page":"Home","title":"jujutracer.AbstractTransformation","text":"(t::AbstractTransformation)(n::Normal)\n\nApplies the transformation to a Normal.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.AbstractTransformation-Tuple{Point}","page":"Home","title":"jujutracer.AbstractTransformation","text":"(t::AbstractTransformation)(p::Point)\n\nApplies the transformation to a Point.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.AbstractTransformation-Tuple{Vec}","page":"Home","title":"jujutracer.AbstractTransformation","text":"(t::AbstractTransformation)(v::Vec)\n\nApplies the transformation to a Vec.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.InvalidPfmFileFormat","page":"Home","title":"jujutracer.InvalidPfmFileFormat","text":"InvalidPfmFileFormat <: Exception\n\nException raised when the PFM file format is invalid or cannot be read.\n\nFields\n\nerror_message::String: The error message describing the issue.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Normal","page":"Home","title":"jujutracer.Normal","text":"Normal(x::Float64, y::Float64, z::Float64)\n\nStruct representing a unit vector (normal) in 3D space.\n\nFields\n\nx::Float64,y::Float64,z::Float64: Coordinates.\n\nMethods\n\nNormal(v::Vec): Create a Normal from a Vec.\nNormal(x::Float64, y::Float64, z::Float64): Create a Normal from x, y, z coordinates.\n\nThrows\n\nArgumentError: If the vector is zero.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Point","page":"Home","title":"jujutracer.Point","text":"Point(x::Float64, y::Float64, z::Float64)\n\nStruct representing a point in 3D space.\n\nFields\n\nx::Float64,y::Float64,z::Float64: Coordinates.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Rx","page":"Home","title":"jujutracer.Rx","text":"struct Rx <: AbstractTransformation\n\nRepresents a rotation transformation around the x-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRx(θ): Creates an Rx instance for a given rotation θ (in radians).\n\nSee also\n\nRy: For rotation around the y-axis.\nRz: For rotation around the z-axis.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Ry","page":"Home","title":"jujutracer.Ry","text":"struct Ry <: AbstractTransformation\n\nRepresents a rotation transformation around the y-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRy(θ): Creates an Ry instance for a given rotation θ (in radians).\n\nSee also\n\nRx: For rotation around the x-axis.\nRz: For rotation around the z-axis.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Rz","page":"Home","title":"jujutracer.Rz","text":"struct Rz <: AbstractTransformation\n\nRepresents a rotation transformation around the z-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRz(θ): Creates an Rz instance for a given rotation θ (in radians).\n\nSee also\n\nRx: For rotation around the x-axis.\nRy: For rotation around the y-axis.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Scaling","page":"Home","title":"jujutracer.Scaling","text":"struct Scaling <: AbstractTransformation\n\nRepresents a scaling transformation in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nScaling(x::Float64, y::Float64, z::Float64):   Creates aScalinginstance with scaling factorsx,y, andzalong the x, y, and z axes, respectively.   Throws anArgumentError` if any of the scaling factors are zero.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Transformation","page":"Home","title":"jujutracer.Transformation","text":"struct Transformation <: AbstractTransformation\n\nRepresents a transformation in 3D space with homogeneous coordinates. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructors\n\nTransformation(): Creates an identity transformation where M and inv are both 4x4 identity matrices.\nTransformation(M::Matrix{Float64}, inv::Matrix{Float64}): Creates a transformation with the given M and inv matrices.\n\nThrows an ArgumentError if:\n\nM or inv are not 4x4 matrices.\nThe last element of M or inv is not 1.0.\nM and inv are not inverses of each other.\n\nNotes\n\nThe M and inv matrices must satisfy the following conditions:\n\nBoth must be 4x4 matrices.\nThe last element of both matrices must be 1.0.\nThe product of M and inv must be approximately equal to the 4x4 identity matrix.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Translation","page":"Home","title":"jujutracer.Translation","text":"struct Translation <: AbstractTransformation\n\nRepresents a translation in 3D space with homogeneous coordinates. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse transformation matrix.\n\nConstructors\n\nTranslation(dx::Float64, dy::Float64, dz::Float64):  Creates a Translation object with translation offsets dx, dy, and dz along the x, y, and z axes, respectively.\nTranslation(v::Vec): Creates a Translation object using a Vec object.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Vec","page":"Home","title":"jujutracer.Vec","text":"Vec(x::Float64, y::Float64, z::Float64)\n\nA struct representing a vector in 3D space.\n\nFields\n\nx::Float64,y::Float64,z::Float64: Coordinates.\n\nMethods\n\nVec(n::Normal): Create a Vec from a Normal.\nVec(p::Point): Create a Vec from a Point.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.hdrimg","page":"Home","title":"jujutracer.hdrimg","text":"hdrimg(w::Int, h::Int)\n\nA struct representing a high dynamic range image (HDR image).\n\nFields\n\nimg::Matrix{RGB}: A matrix of RGB values representing the HDR image.\nw::Int64: The width of the image in pixels.\nh::Int64: The height of the image in pixels.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:≈-Tuple{Union{Rx, Ry, Rz, Scaling, Transformation, Translation}, Union{Rx, Ry, Rz, Scaling, Transformation, Translation}}","page":"Home","title":"Base.:≈","text":"≈(a::Union{Transformation, Translation, Scaling, Rx, Ry, Rz}, b::Union{Transformation, Translation, Scaling, Rx, Ry, Rz})\n\nDefines an approximate equality operator ≈ for geometric transformations.  Two transformations a and b are considered approximately equal if both their transformation matrices (M) and their inverses (inv) are approximately equal.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.:×-Tuple{Union{Normal, Vec}, Union{Normal, Vec}}","page":"Home","title":"jujutracer.:×","text":"a × b\n\nReturn wedge product (times) between Vec or Normal as a Vec.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.:⊙-Tuple{Any, Any}","page":"Home","title":"jujutracer.:⊙","text":"⊙(a, b)\n\nComposition of two transformations, where b is the first acting on the object and a the second.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.:⋅-Tuple{Union{Normal, Vec}, Union{Normal, Vec}}","page":"Home","title":"jujutracer.:⋅","text":"a ⋅ b\n\nReturn scalar product (cdot) between Vec or Normal.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._RGBluminosity","page":"Home","title":"jujutracer._RGBluminosity","text":"_RGBluminosity(color, type = \"LF\")\n\nCalculate the luminosity of a color using different methods.\n\nArguments\n\ncolor: The RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\ntype: The type of luminosity calculation to perform. Options are:\n'LF' : Luminosity function (default),\n'M' : Mean luminosity,\n'W' : Weighted luminosity,\n'D' : Euclidean distance luminosity.\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"function"},{"location":"#jujutracer._average_luminosity-Tuple{hdrimg}","page":"Home","title":"jujutracer._average_luminosity","text":"_average_luminosity(img::hdrimg; type = \"LF\", delta = 0.0001)\n\nReturn the average luminosity of an HDR image, given the type of luminosity calculation to be used and delta to avoid.\n\nArguments\n\nimg::hdrimg: The HDR image for which to calculate the average luminosity.\ntype::String: The type of luminosity calculation to be used. Options are:\nLF: Luminosity function (default)\nM: Mean luminosity\nW: Weighted luminosity\nD: Euclidean distance luminosity\ndelta::Float64: A small value to avoid log(0) for black pixels (default is 0.0001).\n\nReturns\n\nFloat64: The average luminosity of the HDR image.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._clamp_img!-Tuple{hdrimg}","page":"Home","title":"jujutracer._clamp_img!","text":"_clamp_img!(hdr::hdrimg)\n\nClamp the HDR image values to the range [0, 1] using the formula:\n\nR_i  fracR_i1+R_i\n\nArguments\n\nhdr::hdrimg: The HDR image to be clamped.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._lumi_D-Tuple{Any}","page":"Home","title":"jujutracer._lumi_D","text":"_lumi_D(color)\n\nEuclidean distance luminosity function.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._lumi_Func-Tuple{Any}","page":"Home","title":"jujutracer._lumi_Func","text":"_lumi_Func(color)\n\nLuminosity function according to the formula: fracmax(rgb) + min(rgb)2.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._lumi_mean-Tuple{Any}","page":"Home","title":"jujutracer._lumi_mean","text":"_lumi_mean(color)\n\nBasic mean luminosity function.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe mean luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._lumi_weighted-Tuple{Any}","page":"Home","title":"jujutracer._lumi_weighted","text":"_lumi_weighted(color)\n\nWeighted mean luminosity function according to CCIR 601.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._normalize_img!-Tuple{hdrimg}","page":"Home","title":"jujutracer._normalize_img!","text":"_normalize_img!(img::hdrimg: a::T, std::T) where {T<:Real, N}\n\nNormalize an image by using\n\nR_i  R_i  fracR_il\n\nArguments\n\nimg::hdrimg: The HDR image to be normalized.\na::T: A positive value to be used in the normalization formula.\nlum::T: The average luminosity of the image. If not provided, it will be calculated using _average_luminosity.\n\nRaises\n\nArgumentError: If a is not a positive number or if lum is not a number.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._parse_endianness-Tuple{String}","page":"Home","title":"jujutracer._parse_endianness","text":"_parse_endianness(endian::String)\n\nParse endianness of the PFM file from a string.\n\nArguments\n\nendian::String: The string representation of the endianness, expected to be \"±1.0\".\n\nReturns\n\nBool: Returns true if the endianness is little-endian, false if big-endian.\n\nRaises\n\nInvalidPfmFileFormat: If the endianness value is invalid or missing.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._parse_image_size-Tuple{String}","page":"Home","title":"jujutracer._parse_image_size","text":"_parse_image_size(line::String)\n\nRead image size from a string.\n\nArguments\n\nline::String: The string representation of the image size, expected to be a couple of ints \"width height\".\n\nReturns\n\nTuple{Int, Int}: A tuple containing the width and height of the image.\n\nRaises\n\nInvalidPfmFileFormat: If the image size specification is invalid or if the width/height values are not integers.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._read_float-Tuple{IO, Any}","page":"Home","title":"jujutracer._read_float","text":"_read_float(io::IO, is_little_endian)\n\nRead a Float32 value by interpreting 4 bytes with the correct endianness from a buffer.\n\nArguments\n\nio::IO: The input stream from which to read the float.\nis_little_endian::Bool: A boolean indicating whether the float is in little-endian format.\n\nReturns\n\nFloat32: The read float value.\n\nRaises\n\nInvalidPfmFileFormat: If there is an error reading the bytes from the file.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._read_line-Tuple{Any}","page":"Home","title":"jujutracer._read_line","text":"_read_line(io::IO)\n\nRead a line from the input buffer.\n\nArguments\n\nio::IO: The input stream from which to read the line.\n\nReturns\n\nString: The read line.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._write_float!","page":"Home","title":"jujutracer._write_float!","text":"_write_float!(f, io, endianness::Bool=true)\n\nWrite a Float32 value to the output stream with the correct endianness.\n\nArguments\n\nf: The float value to be written.\nio: The output stream to which the float will be written.\nendianness::Bool: A boolean indicating whether to write the float in little-endian format (default is true).\n\n\n\n\n\n","category":"function"},{"location":"#jujutracer._γ_correction!-Tuple{hdrimg}","page":"Home","title":"jujutracer._γ_correction!","text":"_γ_correction!(hdr::hdrimg; γ = 1.0)\n\nApply gamma correction to the HDR image using the formula: \n\nR_i  R_i^1γ\n\nArguments\n\nhdr::hdrimg: The HDR image to be gamma corrected.\nγ::Float64: The gamma value to be used for correction. Must be a positive number (default is 1.0).\n\nRaises\n\nArgumentError: If γ is not a positive number.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.get_matrix-Tuple{hdrimg}","page":"Home","title":"jujutracer.get_matrix","text":"get_matrix(img::hdrimg)\n\nExtract the matrix from an HDR image.\n\nArguments\n\nimg::hdrimg: The HDR image from which to extract the matrix.\n\nReturns\n\nMatrix: The matrix representation of the HDR image.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.inverse-Tuple{jujutracer.AbstractTransformation}","page":"Home","title":"jujutracer.inverse","text":"inverse(a::AbstractTransformation)\n\nReturn the inverse transformation\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.norm-Tuple{Union{Normal, Vec}}","page":"Home","title":"jujutracer.norm","text":"norm(v::Union{Vec, Normal})\n\nCalculates the norm of a vector.\n\nArguments\n\nv::Union{Vec, Normal}: The vector to be processed. Expected to be a Vec or Normal  of 3 values (x, y, z).\n\nReturns\n\nThe norm of the vector.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.normalize-Tuple{Union{Normal, Vec}}","page":"Home","title":"jujutracer.normalize","text":"normalize(v::Union{Vec, Normal})\n\nReturn a normalized vector.\n\nArguments\n\nv::Vec: The vector to be normalized.\n\nReturns\n\nThe normalized vector.\n\nThrows\n\nArgumentError: If the vector is zero.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.read_pfm_image-Tuple{Any}","page":"Home","title":"jujutracer.read_pfm_image","text":"read_pfm_image(io::IO)\n\nRead a PFM image from an input stream.\n\nArguments\n\nio::IO: The input stream from which to read the PFM image.\n\nReturns\n\nhdrimg: The HDR image read from the PFM file.\n\nRaises\n\nInvalidPfmFileFormat: If the PFM file format is invalid or if there are issues reading the file.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.save_ldrimage-Tuple{Matrix, String}","page":"Home","title":"jujutracer.save_ldrimage","text":"save_ldrimage(img_matrix::Matrix, filename::String)\n\nSave an LDR image to a file.\n\nArguments\n\nimg_matrix::Matrix: The matrix representation of the image to be saved.\nfilename::String: The name of the file to save the image to, including the file extension (\".png\" or \".jpg\").\n\nReturns\n\nString: The path to the saved file.\n\nRaises\n\nArgumentError: If the file extension is not valid or if the image values are not clamped.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.squared_norm-Tuple{Union{Normal, Vec}}","page":"Home","title":"jujutracer.squared_norm","text":"squared_norm(v::Union{Vec, Normal})\n\nCalculates the squared norm of a vector.\n\nArguments\n\nv::Union{Vec, Normal}: The vector to be processed. Expected to be a struct of 3 values (x, y, z).\n\nReturns\n\nThe squared norm of the vector.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.to_string-Tuple{T} where T<:Union{Normal, Point, Vec}","page":"Home","title":"jujutracer.to_string","text":"to_string(v::T) where {T<:Union{Point, Vec, Normal}}\n\nConverts a Point, Vec, or Normal object to a string representation.\n\nArguments\n\nv::T: The object to be converted. Expected to be a struct of 3 values (x, y, z).\n\nReturns\n\nA string representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.tone_mapping-Tuple{hdrimg}","page":"Home","title":"jujutracer.tone_mapping","text":"tone_mapping(img::hdrimg; a=0.18, lum = nothing, γ = 1.0)\n\nApply tone mapping to the HDR image.\n\nArguments\n\nimg::hdrimg: The HDR image to be tone-mapped.\na::Float64: A positive value to be used in the normalization formula (default is 0.18).\nlum::Float64: The average luminosity of the image. If not provided, it will be calculated using _average_luminosity.\nγ::Float64: The gamma value to be used for correction. Must be a positive number (default is 1.0).\n\nReturns\n\nhdrimg: The tone-mapped HDR image.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.write_pfm_image","page":"Home","title":"jujutracer.write_pfm_image","text":"write_pfm_image(img::hdrimg, io, endianness::Bool=true)\n\nWrite a PFM file encodiding the content of an hdrimg\n\nArguments\n\nimg::hdrimg: The HDR image to be written to the PFM file.\nio::IO: The output stream to which the PFM image will be written.\nendianness::Bool: A boolean indicating whether to write the float values in little-endian format (default is true).\n\n\n\n\n\n","category":"function"}]
}
