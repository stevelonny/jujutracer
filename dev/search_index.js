var documenterSearchIndex = {"docs":
[{"location":"#jujutracer-documentation","page":"Home","title":"jujutracer documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the package jujutracer.","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert a PFM file into a LDR format such as .png or .jpg. Need a and gamma values specified.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia main.jl <pfm_file> <a> <gamma> <output_file>","category":"page"},{"location":"#Module-Index","page":"Home","title":"Module Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [jujutracer]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"#Detailed-API","page":"Home","title":"Detailed API","text":"","category":"section"},{"location":"#jujutracer.AbstractCamera","page":"Home","title":"jujutracer.AbstractCamera","text":"abstract type AbstractCamera\n\nAbstact type AbstractCamera\n\nAbstractCamera(u, v) returns a ray fired in the pixel (u, v) of the screen\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.AbstractShape","page":"Home","title":"jujutracer.AbstractShape","text":"abstract type AbstractShape\n\nAbstract type for all shapes. Not guaranteed to be water-tight. Cannot be used to create CSG shapes.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.AbstractSolid","page":"Home","title":"jujutracer.AbstractSolid","text":"abstract type AbstractSolid <: AbstractShape\n\nAbstract type for solid shapes. Considered water-tight. Can be used to create CSG shapes. Made concrete by Sphere.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.AbstractTransformation","page":"Home","title":"jujutracer.AbstractTransformation","text":"AbstractTransformation\n\nAn abstract type that serves as a base for defining various geometric transformations. Made concrete by Transformation, Translation, Scaling, Rx, Ry, and Rz.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.AbstractTransformation-Tuple{Normal}","page":"Home","title":"jujutracer.AbstractTransformation","text":"(t::AbstractTransformation)(n::Normal)\n\nApplies the transformation to a Normal.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.AbstractTransformation-Tuple{Point}","page":"Home","title":"jujutracer.AbstractTransformation","text":"(t::AbstractTransformation)(p::Point)\n\nApplies the transformation to a Point.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.AbstractTransformation-Tuple{Vec}","page":"Home","title":"jujutracer.AbstractTransformation","text":"(t::AbstractTransformation)(v::Vec)\n\nApplies the transformation to a Vec.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.Box","page":"Home","title":"jujutracer.Box","text":"struct Box <: AbstractSolid\n\nAn axis-aligned box (rectangular cuboid) defined by two opposite corners.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the box.\nP1::Point: One corner of the box (minimum x, y, z).\nP2::Point: The opposite corner of the box (maximum x, y, z).\nMat::Material: The material of the box.\n\nConstructors\n\nBox(): Creates a new box with default transformation and material.\nBox(Tr::AbstractTransformation): Creates a new box with the specified transformation and default material.\nBox(P1::Point, P2::Point): Creates a new box with the specified corners and default transformation and material.\nBox(P1::Point, P2::Point, Mat::Material): Creates a new box with the specified corners and material.\nBox(Tr::AbstractTransformation, P1::Point, P2::Point): Creates a new box with the specified transformation and corners.\nBox(Tr::AbstractTransformation, P1::Point, P2::Point, Mat::Material): Creates a new box with the specified transformation, corners, and material.\nBox(Mat::Material): Creates a new box with the default transformation and the specified material.\nBox(Tr::AbstractTransformation, Mat::Material): Creates a new box with the specified transformation and material.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.CSGDifference","page":"Home","title":"jujutracer.CSGDifference","text":"struct CSGDifference <: AbstractSolid\n\nRepresents the difference of two solid shapes.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the difference.\nSh1::AbstractSolid, Sh2::AbstractSolid: The two solid shapes where Sh1 - Sh2 is computed.\n\nSee also\n\nCSGUnion: Represents the union of two solid shapes.\nCSGIntersection: Represents the intersection of two solid shapes.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.CSGIntersection","page":"Home","title":"jujutracer.CSGIntersection","text":"struct CSGIntersection <: AbstractSolid\n\nRepresents the intersection of two solid shapes.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the intersection.\nSh1::AbstractSolid, Sh2::AbstractSolid: The two solid shapes being intersected.\n\nSee also\n\nCSGUnion: Represents the union of two solid shapes.\nCSGDifference: Represents the difference of two solid shapes.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.CSGUnion","page":"Home","title":"jujutracer.CSGUnion","text":"struct CSGUnion <: AbstractSolid\n\nRepresents the union of two solid shapes.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the union.\nSh1::AbstractSolid, Sh2::AbstractSolid: The two solid shapes being united.\n\nSee also\n\nCSGDifference: Represents the difference of two solid shapes.\nCSGIntersection: Represents the intersection of two solid shapes.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.CheckeredPigment","page":"Home","title":"jujutracer.CheckeredPigment","text":"CheckeredPigment(col::Int32, row::Int32, dark::RGB, bright::RGB)\n\nCheckered pigment for a Shape, subdiveded in row rows and col columns with alternate dark and bright color\n\nFields\n\ncol number of horizontal subdivisions\nrow number of vertical subdivisions\ndark color of the dark squares\nbright color of the bright squares\n\nFunctional Usage\n\nCheckeredPigment(p::SurfacePoint) return the RGB associated to the (u, v) coordinates of the SurfacePoint \n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Cylinder","page":"Home","title":"jujutracer.Cylinder","text":"struct Cylinder <: AbstractSolid\n\nA sphere. This structure is a subtype of AbstractSolid.\n\nFields\n\nTr::Transformation: the transformation applied to the sphere.\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.DiffusiveBRDF","page":"Home","title":"jujutracer.DiffusiveBRDF","text":"DiffusiveBRDF(Pigment::AbstractPigment, R::Float64)\n\nDiffusive BRDF with reflective pigment Pigment.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Flat","page":"Home","title":"jujutracer.Flat","text":"Flat(world::World)\n\nFlat renderer of the scene. Returns the Emition pigment of the hitten shapes\n\nFields\n\nworld::World the world containing the scene\n\nFunctional Usage\n\nFlat(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.HitRecord","page":"Home","title":"jujutracer.HitRecord","text":"HitRecord(world_point::Point, normal::Normal, surface_point::SurfacePoint, t::Float64, ray::Ray)\n\nInformation about an intersection\n\nFields\n\nworld_P::Point the point in the world where the ray hit\nnormal::Normal the normal vector at the point of intersection\nsurface_P::SurfacePoint the point on the surface where the ray hit\nt::Float64 the distance from the ray origin to the hit point\nray::Ray the ray that hit the surface\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.ImagePigment","page":"Home","title":"jujutracer.ImagePigment","text":"ImagePigment(img::hdrimg)\n\nPrint the image img as pigment of the surface\n\nFields\n\nimg::hdrimg the image in hdr format\n\nFunctional Usage\n\nImagePigment(p::SurfacePoint) return the RGB of to the (u, v) coordinates of the SurfacePoint associated to the corresponding element of img\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.ImageTracer","page":"Home","title":"jujutracer.ImageTracer","text":"struct ImageTracer\n\nConvenient struct to hold the hdrimage and the camera.\n\nFields\n\nimg::hdrimg: The HDR image to be traced.\ncamera::AbstractCamera: The camera used for tracing rays. Can be either Orthogonal or Perspective.\n\nConstructor\n\nImageTracer(): Creates a new ImageTracer with a default HDR image and an orthogonal camera.\nImageTracer(img::hdrimg, camera::AbstractCamera): Creates a new ImageTracer with the specified HDR image and camera.\n\nFunctional Usage\n\nImageTracer(fun::Function): tracing the image with fun renderer.\nImageTracer(fun::Function, AA::Int64, pcg::PCG): tracing the image with fun renderer and Anti-Aliasing method with AA^2 subdivision in the pixel.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.ImageTracer-Tuple{Function, Int64, PCG}","page":"Home","title":"jujutracer.ImageTracer","text":"(it::ImageTracer)(fun::Function, AA::Int64, pcg::PCG)\n\nApply a function to each pixel in the image with Anti-Aliasing (AA) leveraging stratified random sampling.\n\nArguments\n\nfun::Function: Must be a function that takes a ::Ray as input and returns a color (ColorTypes.RGB).\nAA::Int64: The Anti-Aliasing factor, which determines the number of samples per pixel (AA^2 samples).\npcg::PCG: A pseudo-random number generator for generating random offsets in the pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ImageTracer-Tuple{Function}","page":"Home","title":"jujutracer.ImageTracer","text":"(it::ImageTracer)(fun::Function)\n\nApply a function to each pixel in the image. Leverage parallel processing for performance.\n\nArguments\n\nfun::Function: Must be a function that takes a ::Ray as input and returns a color (ColorTypes.RGB).\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ImageTracer-Tuple{Int64, Int64}","page":"Home","title":"jujutracer.ImageTracer","text":"(it::ImageTracer)(col::Int, row::Int; u_pixel::Float64 = 0.5, v_pixel::Float64 = 0.5)\n\nReturn the ray cast from the camera through the pixel at (col, row) in the image.\n\nArguments\n\ncol_pixel::Int, row_pixel::Int: The column and row indexes of the pixel in the image.\nu_pixel::Float64, v_pixel::Float64: The pixel offset in the u and v directions (default is 0.5, center of the pixel).\n\nReturns\n\nRay: The ray cast from the camera through the specified pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.InvalidPfmFileFormat","page":"Home","title":"jujutracer.InvalidPfmFileFormat","text":"InvalidPfmFileFormat <: Exception\n\nException raised when the PFM file format is invalid or cannot be read.\n\nFields\n\nerror_message::String: The error message describing the issue.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Material","page":"Home","title":"jujutracer.Material","text":"struct Material\n\nFields\n\nEmition::AbstractPigment: the pigement with which the radiation is emitted.\nBRDF::AbstractBRDF: the BRDF of the material.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Normal","page":"Home","title":"jujutracer.Normal","text":"Normal(x::Float64, y::Float64, z::Float64)\n\nStruct representing a unit vector (normal) in 3D space.\n\nFields\n\nx::Float64,y::Float64,z::Float64: Coordinates.\n\nMethods\n\nNormal(v::Vec): Create a Normal from a Vec.\nNormal(x::Float64, y::Float64, z::Float64): Create a Normal from x, y, z coordinates.\n\nThrows\n\nArgumentError: If the vector is zero.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.OnOff","page":"Home","title":"jujutracer.OnOff","text":"OnOff(world::World)\n\nOnOff renderer of the scene. Returns white if the ray hits something, balck otherwise\n\nFields\n\nworld::World the world containing the scene\n\nFunctional Usage\n\nOnOff(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Orthogonal","page":"Home","title":"jujutracer.Orthogonal","text":"Orthogonal\n\nOrthogonal camera type\n\nFields\n\nt::Transformation the transformation related to the camera's standing\na_ratio::Float64 aspect ratio of the screen of the camera\n\nConstructor\n\nOrthogonal() creates an orthogonal camera with Identity Transformation and a 16:9 aspect ratio\nOrtoghonal(t = trans, a_ratio = a) creates an orthogonal camera with trans Transformation and an a aspect ratio\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Parallelogram","page":"Home","title":"jujutracer.Parallelogram","text":"struct Parallelogram <: AbstractShape\n\nParallelogram\n\n   C-----p\n  /     /\n /     /\nA-----B\n\nFields\n\nt::Transformation: the transformation applied to the Parallelogram.\nA, B, C::Point: the vertices defining the quadrilateral's \nMat::Material: the material of the shape\n\nConstructor\n\nParallelogram(): creates a parallelogram with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nParallelogram(Tr::AbstractTransformation): creates a parallelogram with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nParallelogram(Mat::Material): creates a parallelogram with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nParallelogram(Tr::AbstractTransformation, Mat::Material): creates a parallelogram with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nParallelogram(A::Point, B::Point, C::Point): creates a parallelogram with Identity Transformation and vertices A, B, C and a default material.\nParallelogram(A::Point, B::Point, C::Point, Mat::Material): creates a parallelogram with Identity Transformation and vertices A, B, C and a Mat material.\nParallelogram(A::Point, AB::Vec, AC::Vec): creates a parallelogram with Identity Transformation and vertices A, A + AB, A + AC and a default material.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.PathTracer","page":"Home","title":"jujutracer.PathTracer","text":"PathTracer(world::World)\n\nFlat renderer of the scene. Returns the Emition pigment of the hitten shapes\n\nFields\n\nworld::World: the world containing the scene\nbackg::RGB: the background color when the ray doesn't intersect anything\nrnd::PCG: the random number generator\nn_rays::INt64: the number of rays fired from the hitten point\ndepth::Int64: the maximum depth to be reached by a ray\nrussian::Int64: number of iteration before playing with Russian Roulet\n\nFunctional Usage\n\nPathTracer(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Perspective","page":"Home","title":"jujutracer.Perspective","text":"Perspective\n\nPerspective camera type\n\nFields\n\nt::Transformation the transformation related to the camera's standing\na_ratio::Float64 aspect ratio of the screen of the camera\n\nConstructor\n\nPerspective() creates a perspective camera with Identity Transformation, a 16:9 aspect ratio placed in (-1, 0, 0)\nPerspective(d = dist, t = trans, a_ratio = a) creates a perspective camera with trans Transformation, an a aspect ratio placed in (-d, 0, 0)\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Plane","page":"Home","title":"jujutracer.Plane","text":"struct Plane <: AbstractShape\n\nA plane. This structure is a subtype of AbstractShape.\n\nFields\n\nt::Transformation: the transformation applied to the plane\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Point","page":"Home","title":"jujutracer.Point","text":"Point(x::Float64, y::Float64, z::Float64)\n\nStruct representing a point in 3D space.\n\nFields\n\nx::Float64,y::Float64,z::Float64: Coordinates.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Ray","page":"Home","title":"jujutracer.Ray","text":"Ray(origin::Point, dir::Vec, tmin::Float=1e-5, tmax::Float=Inf, depth::Int=0)\n\nA struct representing a ray in 3D space.\n\nFields\n\norigin::Point: The origin point of the ray.\ndir::Vec: The direction vector of the ray.\ntmin::Float: The minimum distance along the ray (default is le-5).\ntmax::Float: The maximum distance along the ray (default is Inf).\ndepth::Int: The depth of the ray (default is 0).\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Ray-Tuple{Float64}","page":"Home","title":"jujutracer.Ray","text":"(r::Ray)(t::Float64)\n\nReturn the point along the ray at distance t from the origin.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.Rectangle","page":"Home","title":"jujutracer.Rectangle","text":"struct Rectangle <: AbstractShape\n\n1x1 Rectangle on xy plane, centered in the origin\n\nFields\n\nt::Transformation: the transformation applied to the plane\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Rx","page":"Home","title":"jujutracer.Rx","text":"struct Rx <: AbstractTransformation\n\nRepresents a rotation transformation around the x-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRx(θ): Creates an Rx instance for a given rotation θ (in radians).\n\nSee also\n\nRy: For rotation around the y-axis.\nRz: For rotation around the z-axis.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Ry","page":"Home","title":"jujutracer.Ry","text":"struct Ry <: AbstractTransformation\n\nRepresents a rotation transformation around the y-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRy(θ): Creates an Ry instance for a given rotation θ (in radians).\n\nSee also\n\nRx: For rotation around the x-axis.\nRz: For rotation around the z-axis.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Rz","page":"Home","title":"jujutracer.Rz","text":"struct Rz <: AbstractTransformation\n\nRepresents a rotation transformation around the z-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRz(θ): Creates an Rz instance for a given rotation θ (in radians).\n\nSee also\n\nRx: For rotation around the x-axis.\nRy: For rotation around the y-axis.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Scaling","page":"Home","title":"jujutracer.Scaling","text":"struct Scaling <: AbstractTransformation\n\nRepresents a scaling transformation in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nScaling(x::Float64, y::Float64, z::Float64):   Creates aScalinginstance with scaling factorsx,y, andzalong the x, y, and z axes, respectively.   Throws anArgumentError` if any of the scaling factors are zero.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.SpecularBRDF","page":"Home","title":"jujutracer.SpecularBRDF","text":"SpecularBRDF(Pigment::AbstractPigment, R::Float64)\n\nSpecular BRDF with reflective pigment Pigment.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Sphere","page":"Home","title":"jujutracer.Sphere","text":"struct Sphere <: AbstractSolid\n\nA sphere. This structure is a subtype of AbstractSolid.\n\nFields\n\nt::Transformation: the transformation applied to the sphere.\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.SurfacePoint","page":"Home","title":"jujutracer.SurfacePoint","text":"struct SurfacePoint\n\nA struct representing a point on the surface of a shape.\n\nFields\n\nu::Float64, `v::Float64: the (u,v) coordinates of the point on the surface.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Transformation","page":"Home","title":"jujutracer.Transformation","text":"struct Transformation <: AbstractTransformation\n\nRepresents a transformation in 3D space with homogeneous coordinates. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructors\n\nTransformation(): Creates an identity transformation where M and inv are both 4x4 identity matrices.\nTransformation(M::Matrix{Float64}, inv::Matrix{Float64}): Creates a transformation with the given M and inv matrices.\nTransformation(M::Matrix{Float64}, inv::Matrix{Float64}, unsafe::Unsafe): Creates a transformation with the given M and inv matrices, without veryfing the inputs.\n\nThrows an ArgumentError if:\n\nM or inv are not 4x4 matrices.\nThe last element of M or inv is not 1.0.\nM and inv are not inverses of each other.\n\nNotes\n\nThe M and inv matrices must satisfy the following conditions:\n\nBoth must be 4x4 matrices.\nThe last element of both matrices must be 1.0.\nThe product of M and inv must be approximately equal to the 4x4 identity matrix.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Translation","page":"Home","title":"jujutracer.Translation","text":"struct Translation <: AbstractTransformation\n\nRepresents a translation in 3D space with homogeneous coordinates. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse transformation matrix.\n\nConstructors\n\nTranslation(dx::Float64, dy::Float64, dz::Float64):  Creates a Translation object with translation offsets dx, dy, and dz along the x, y, and z axes, respectively.\nTranslation(v::Vec): Creates a Translation object using a Vec object.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Triangle","page":"Home","title":"jujutracer.Triangle","text":"struct Triangle <: AbstractShape\n\nTriangle.\n\nFields\n\nt::Transformation: the transformation applied to the triangle\nA, B, C::Point: the vertices of the triangle\nMat::Material: the material of the shape\n\nConstructor\n\nTriangle(): creates a triangle with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nTriangle(Tr::AbstractTransformation): creates a triangle with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nTriangle(Mat::Material): creates a triangle with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nTriangle(Tr::AbstractTransformation, Mat::Material): creates a triangle with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nTriangle(A::Point, B::Point, C::Point): creates a triangle with Identity Transformation and vertices A, B, C and a default material.\nTriangle(A::Point, B::Point, C::Point, Mat::Material): creates a triangle with Identity Transformation and vertices A, B, C and a Mat material.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.UniformPigment","page":"Home","title":"jujutracer.UniformPigment","text":"UniformPigment()\n\nUniform Pigment for Shapes\n\nFields\n\ncolor::RBG the uniform color\n\nFunctional Usage\n\nUniformPigment(p::SurfacePoint) return the RGB associated to the (u, v) coordinates of the SurfacePoint\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Unsafe","page":"Home","title":"jujutracer.Unsafe","text":"struct Unsafe\n\nA singleton struct used to indicate unsafe operations in transformations. See also Transformation and _unsafe_inverse.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.Vec","page":"Home","title":"jujutracer.Vec","text":"Vec(x::Float64, y::Float64, z::Float64)\n\nA struct representing a vector in 3D space.\n\nFields\n\nx::Float64,y::Float64,z::Float64: Coordinates.\n\nMethods\n\nVec(n::Normal): Create a Vec from a Normal.\nVec(p::Point): Create a Vec from a Point.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.World","page":"Home","title":"jujutracer.World","text":"struct World\n\nA struct representing a collection of shapes in a 3D world.\n\nFields\n\nshapes::Vector{Shapes}: the vector containing the shapes in the world.\n\nConstructor\n\nWorld(): creates a new World with an empty vector of shapes.\nWorld(S::Vector{Shapes}): creates a new World with the specified vector of shapes.\n\nSee also\n\nAbstractShape: the abstract type for all shapes.\nSphere: a concrete implementation of AbstractShape representing a sphere.\nPlane: a concrete implementation of AbstractShape representing a plane.\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer._inf_Cylinder","page":"Home","title":"jujutracer._inf_Cylinder","text":"struct _inf_Cylinder <: AbstractSolid\n\nA sphere. This structure is a subtype of AbstractSolid.\n\nFields\n\nTr::Transformation: the transformation applied to the sphere.\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"#jujutracer.hdrimg","page":"Home","title":"jujutracer.hdrimg","text":"hdrimg(w::Int, h::Int)\n\nA struct representing a high dynamic range image (HDR image). Getter and setter methods are defined for accessing and modifying pixel values. Access is done using 0-based indexing, so the first pixel is at (0, 0): img[0, 0]; while the bottom right pixel is at (w-1, h-1): img[w-1, h-1].\n\n    img = [ (0  , 0)   (0  , 1) ... (0  , w-1)\n            (1  , 0)   (1  , 1) ... (1  , w-1)\n             ...\n            (h-1, 1)   (h-1, 2) ... (h-1, w-1) ]\n\nFields\n\nimg::Matrix{RGB}: A matrix of RGB values representing the HDR image. Not intedend to be accessed directly.\nw::Int64: The width of the image in pixels.\nh::Int64: The height of the image in pixels.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:≈-Tuple{jujutracer.AbstractTransformation, jujutracer.AbstractTransformation}","page":"Home","title":"Base.:≈","text":"≈(a::Union{Transformation, Translation, Scaling, Rx, Ry, Rz}, b::Union{Transformation, Translation, Scaling, Rx, Ry, Rz})\n\nDefines an approximate equality operator ≈ for geometric transformations.  Two transformations a and b are considered approximately equal if both their transformation matrices (M) and their inverses (inv) are approximately equal.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.:×-Tuple{Union{Normal, Vec}, Union{Normal, Vec}}","page":"Home","title":"jujutracer.:×","text":"a × b\n\nReturn wedge product (times) between Vec or Normal as a Vec.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.:⊙-Tuple{Any, Any}","page":"Home","title":"jujutracer.:⊙","text":"⊙(a, b)\n\nComposition of two transformations, where b is the first acting on the object and a the second.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.:⋅-Tuple{Union{Normal, Vec}, Union{Normal, Vec}}","page":"Home","title":"jujutracer.:⋅","text":"a ⋅ b\n\nReturn scalar product (cdot) between Vec or Normal.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._LFD-Tuple{Point, Point}","page":"Home","title":"jujutracer._LFD","text":"_LFD(P1::Point, P2::Point)\n\nReturn the corner of the box with the minimum x, y, z coordinates (Left, Front, Down).\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._RBU-Tuple{Point, Point}","page":"Home","title":"jujutracer._RBU","text":"_RBU(P1::Point, P2::Point)\n\nReturn the corner of the box with the maximum x, y, z coordinates (Right, Back, Up).\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._RGBluminosity","page":"Home","title":"jujutracer._RGBluminosity","text":"_RGBluminosity(color, type = \"LF\")\n\nCalculate the luminosity of a color using different methods.\n\nArguments\n\ncolor: The RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\ntype: The type of luminosity calculation to perform. Options are:\n'LF' : Luminosity function (default),\n'M' : Mean luminosity,\n'W' : Weighted luminosity,\n'D' : Euclidean distance luminosity.\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"function"},{"location":"#jujutracer._average_luminosity-Tuple{hdrimg}","page":"Home","title":"jujutracer._average_luminosity","text":"_average_luminosity(img::hdrimg; type = \"LF\", delta = 0.0001)\n\nReturn the average luminosity of an HDR image, given the type of luminosity calculation to be used and delta to avoid.\n\nArguments\n\nimg::hdrimg: The HDR image for which to calculate the average luminosity.\ntype::String: The type of luminosity calculation to be used. Options are:\nLF: Luminosity function (default)\nM: Mean luminosity\nW: Weighted luminosity\nD: Euclidean distance luminosity\ndelta::Float64: A small value to avoid log(0) for black pixels (default is 0.0001).\n\nReturns\n\nFloat64: The average luminosity of the HDR image.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._clamp_img!-Tuple{hdrimg}","page":"Home","title":"jujutracer._clamp_img!","text":"_clamp_img!(hdr::hdrimg)\n\nClamp the HDR image values to the range [0, 1] using the formula:\n\nR_i  fracR_i1+R_i\n\nArguments\n\nhdr::hdrimg: The HDR image to be clamped.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._cylinder_normal-Tuple{Point, Vec}","page":"Home","title":"jujutracer._cylinder_normal","text":"_cylinder_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the sphere.\n\nArguments\n\np::Point: the point on the sphere.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the sphere's surface at the point.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._lumi_D-Tuple{Any}","page":"Home","title":"jujutracer._lumi_D","text":"_lumi_D(color)\n\nEuclidean distance luminosity function.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._lumi_Func-Tuple{Any}","page":"Home","title":"jujutracer._lumi_Func","text":"_lumi_Func(color)\n\nLuminosity function according to the formula: fracmax(rgb) + min(rgb)2.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._lumi_mean-Tuple{Any}","page":"Home","title":"jujutracer._lumi_mean","text":"_lumi_mean(color)\n\nBasic mean luminosity function.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe mean luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._lumi_weighted-Tuple{Any}","page":"Home","title":"jujutracer._lumi_weighted","text":"_lumi_weighted(color)\n\nWeighted mean luminosity function according to CCIR 601.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._mat-Tuple{Vec, Vec, Vec}","page":"Home","title":"jujutracer._mat","text":"_mat(a::Vec, b::Vec, c::Vec)\n\nReturns a Matrix build with the transposed Vectors aᵗ, bᵗ and cᵗ.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._normalize_img!-Tuple{hdrimg}","page":"Home","title":"jujutracer._normalize_img!","text":"_normalize_img!(img::hdrimg: a::T, std::T) where {T<:Real, N}\n\nNormalize an image by using\n\nR_i  R_i  fracR_il\n\nArguments\n\nimg::hdrimg: The HDR image to be normalized.\na::T: A positive value to be used in the normalization formula.\nlum::T: The average luminosity of the image. If not provided, it will be calculated using _average_luminosity.\n\nRaises\n\nArgumentError: If a is not a positive number or if lum is not a number.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._parse_endianness-Tuple{String}","page":"Home","title":"jujutracer._parse_endianness","text":"_parse_endianness(endian::String)\n\nParse endianness of the PFM file from a string.\n\nArguments\n\nendian::String: The string representation of the endianness, expected to be \"±1.0\".\n\nReturns\n\nBool: Returns true if the endianness is little-endian, false if big-endian.\n\nRaises\n\nInvalidPfmFileFormat: If the endianness value is invalid or missing.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._parse_image_size-Tuple{String}","page":"Home","title":"jujutracer._parse_image_size","text":"_parse_image_size(line::String)\n\nRead image size from a string.\n\nArguments\n\nline::String: The string representation of the image size, expected to be a couple of ints \"width height\".\n\nReturns\n\nTuple{Int, Int}: A tuple containing the width and height of the image.\n\nRaises\n\nInvalidPfmFileFormat: If the image size specification is invalid or if the width/height values are not integers.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._plane_normal-Tuple{Point, Vec}","page":"Home","title":"jujutracer._plane_normal","text":"_plane_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the plane\n\nArguments\n\np::Point: the point on the plane.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the plane's surface at the point.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._point_to_uv-Tuple{Box, Point, Normal}","page":"Home","title":"jujutracer._point_to_uv","text":"_point_to_uv(box::Box, p::Point, norm::Normal)\n\nCalculate the UV coordinates of a point on the surface of a box, using the surface normal to determine which face is being mapped. The UV mapping follows a cube-unwrapping scheme:\n\n    +----+------+-----+----+\n    |xxxx| Top  |xxxxxxxxxx|\n    |xxxx| (Y+) |xxxxxxxxxx| \n2/3 +----+------+-----+----+\n    |Left|Front |Right|Back|\n    |(X-)|(Z+)  |(X+) |(Z-)|\n1/3 +----+------+-----+----+\n    |xxxx|Bottom|xxxxxxxxxx|\n    |xxxx| (Y-) |xxxxxxxxxx|\n    +----+------+-----+----+\n\nArguments\n\nbox::Box: The box shape.\np::Point: The point on the box surface (in local box coordinates).\nnorm::Normal: The untransformed normal at the point, used to determine which face is being mapped.\n\nReturns\n\nSurfacePoint: The UV coordinates (u, v) of the point on the box surface.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._point_to_uv-Tuple{Plane, Point}","page":"Home","title":"jujutracer._point_to_uv","text":"_point_to_uv(S::Plane, p::Point)\n\nCalculate the UV coordinates of a point on the plane in PBC\n\nArguments\n\np::Point: the point on the plane\n\nReturns\n\nSurfacePoint: the UV coordinates of the point in PBC\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._point_to_uv-Tuple{Rectangle, Point}","page":"Home","title":"jujutracer._point_to_uv","text":"pointto_uv(S::Rectangle, p::Point)\n\nCalculate the UV coordinates of a point on the plane in PBC\n\nArguments\n\np::Point: the point on the rectangle\n\nReturns\n\nSurfacePoint: the UV coordinates of the point in PBC\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._point_to_uv-Tuple{Sphere, Point}","page":"Home","title":"jujutracer._point_to_uv","text":"_point_to_uv(S::Sphere, p::Point)\n\nCalculate the UV coordinates of a point on the sphere.\n\nArguments\n\nS::Sphere the Sphere\np::Point the point on the sphere\n\nReturns\n\nSurfacePoint: the UV coordinates of the point on the sphere\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._point_to_uv-Tuple{jujutracer._inf_Cylinder, Point}","page":"Home","title":"jujutracer._point_to_uv","text":"_point_to_uv(S::_inf_Cylinder, p::Point)\n\nCalculate the UV coordinates of a point on the sphere.\n\nArguments\n\nS::_inf_Cylinder the infCylinder\np::Point the point on the sphere\n\nReturns\n\nSurfacePoint: the UV coordinates of the point on the sphere\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._read_float-Tuple{IO, Any}","page":"Home","title":"jujutracer._read_float","text":"_read_float(io::IO, is_little_endian)\n\nRead a Float32 value by interpreting 4 bytes with the correct endianness from a buffer.\n\nArguments\n\nio::IO: The input stream from which to read the float.\nis_little_endian::Bool: A boolean indicating whether the float is in little-endian format.\n\nReturns\n\nFloat32: The read float value.\n\nRaises\n\nInvalidPfmFileFormat: If there is an error reading the bytes from the file.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._read_line-Tuple{Any}","page":"Home","title":"jujutracer._read_line","text":"_read_line(io::IO)\n\nRead a line from the input buffer.\n\nArguments\n\nio::IO: The input stream from which to read the line.\n\nReturns\n\nString: The read line.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._rectangle_normal-Tuple{Point, Vec}","page":"Home","title":"jujutracer._rectangle_normal","text":"_rectangle_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the rectangle\n\nArguments\n\np::Point: the point on the rectangle.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the rectangle's surface at the point.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._sarrus-Tuple{Matrix}","page":"Home","title":"jujutracer._sarrus","text":"_sarrus(Mat::Matrix)\n\nImplement the Sarrus method for calculation of the determinant of a 3x3 Matrix.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._sarrus-Tuple{Vec, Vec, Vec}","page":"Home","title":"jujutracer._sarrus","text":"_sarrus(a::Vec, b::Vec, c::Vec)\n\nEfficiently computes the determinant of the 3x3 matrix whose columns are a, b, and c, without allocating a matrix.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._sphere_normal-Tuple{Point, Vec}","page":"Home","title":"jujutracer._sphere_normal","text":"_sphere_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the sphere.\n\nArguments\n\np::Point: the point on the sphere.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the sphere's surface at the point.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._unsafe_inverse-Tuple{jujutracer.AbstractTransformation}","page":"Home","title":"jujutracer._unsafe_inverse","text":"_unsafe_inverse(a::AbstractTransformation)\n\nReturn the inverse transformation without checking if the matrices are inverses of each other.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer._write_float!","page":"Home","title":"jujutracer._write_float!","text":"_write_float!(f, io, endianness::Bool=true)\n\nWrite a Float32 value to the output stream with the correct endianness.\n\nArguments\n\nf: The float value to be written.\nio: The output stream to which the float will be written.\nendianness::Bool: A boolean indicating whether to write the float in little-endian format (default is true).\n\n\n\n\n\n","category":"function"},{"location":"#jujutracer._γ_correction!-Tuple{hdrimg}","page":"Home","title":"jujutracer._γ_correction!","text":"_γ_correction!(hdr::hdrimg; γ = 1.0)\n\nApply gamma correction to the HDR image using the formula: \n\nR_i  R_i^1γ\n\nArguments\n\nhdr::hdrimg: The HDR image to be gamma corrected.\nγ::Float64: The gamma value to be used for correction. Must be a positive number (default is 1.0).\n\nRaises\n\nArgumentError: If γ is not a positive number.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.create_onb_from_z-Tuple{Union{Normal, Vec}}","page":"Home","title":"jujutracer.create_onb_from_z","text":"create_onb_from_z(normal::Union{Vec, Normal})\n\nCreates an orthonormal basis (ONB) from a given normal vector.\n\nArguments\n\nnormal::Union{Vec, Normal}: The NORMAL vector from which to create the ONB. It can be a Vec or Normal.\n\nReturns\n\nA tuple of three Vec objects representing the orthonormal basis vectors.\ne1: The first basis vector.\ne2: The second basis vector.\nnormal: The normal vector itself.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.get_matrix-Tuple{hdrimg}","page":"Home","title":"jujutracer.get_matrix","text":"get_matrix(img::hdrimg)\n\nExtract the matrix from an HDR image.\n\nArguments\n\nimg::hdrimg: The HDR image from which to extract the matrix.\n\nReturns\n\nMatrix: The matrix representation of the HDR image.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.internal-Tuple{Box, Point}","page":"Home","title":"jujutracer.internal","text":"internal(box::Box, P::Point)\n\nCheck if a point is inside the box.\n\nArguments\n\nbox::Box: The box to check.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the box, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.internal-Tuple{CSGDifference, Point}","page":"Home","title":"jujutracer.internal","text":"internal(D::CSGDifference, P::Point)\n\nChecks if a point is inside the difference of two solid shapes.\n\nArguments\n\nD::CSGDifference: The difference of solid shapes.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the difference, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.internal-Tuple{CSGIntersection, Point}","page":"Home","title":"jujutracer.internal","text":"internal(I::CSGIntersection, P::Point)\n\nChecks if a point is inside the intersection of two solid shapes.\n\nArguments\n\nI::CSGIntersection: The intersection of solid shapes.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the intersection, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.internal-Tuple{CSGUnion, Point}","page":"Home","title":"jujutracer.internal","text":"internal(U::CSGUnion, P::Point)\n\nChecks if a point is inside the union of two solid shapes.\n\nArguments\n\nU::CSGUnion: The union of solid shapes.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the union, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.internal-Tuple{Sphere, Point}","page":"Home","title":"jujutracer.internal","text":"internal(S::Sphere, P::Point)\n\nChecks if a point is inside a sphere.\n\nArguments\n\nS::Sphere: The sphere to check.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the sphere, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.internal-Tuple{jujutracer._inf_Cylinder, Point}","page":"Home","title":"jujutracer.internal","text":"internal(S::_inf_Cylinder, P::Point)\n\nChecks if a point is inside a sphere.\n\nArguments\n\nS::_inf_Cylinder: The sphere to check.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the sphere, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.inverse-Tuple{jujutracer.AbstractTransformation}","page":"Home","title":"jujutracer.inverse","text":"inverse(a::AbstractTransformation)\n\nReturn the inverse transformation.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.norm-Tuple{Union{Normal, Vec}}","page":"Home","title":"jujutracer.norm","text":"norm(v::Union{Vec, Normal})\n\nCalculates the norm of a vector.\n\nArguments\n\nv::Union{Vec, Normal}: The vector to be processed. Expected to be a Vec or Normal  of 3 values (x, y, z).\n\nReturns\n\nThe norm of the vector.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.normalize-Tuple{Union{Normal, Vec}}","page":"Home","title":"jujutracer.normalize","text":"normalize(v::Union{Vec, Normal})\n\nReturn a normalized vector.\n\nArguments\n\nv::Vec: The vector to be normalized.\n\nReturns\n\nThe normalized vector.\n\nThrows\n\nArgumentError: If the vector is zero.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.rand_pcg-Tuple{PCG}","page":"Home","title":"jujutracer.rand_pcg","text":"rand_pcg(pcg::PCG)::UInt32\n\nGenerate a random 32-bit unsigned integer using the PCG algorithm.\n\nArguments\n\npcg::PCG: The PCG instance to use for random number generation.\n\nReturns\n\nRandom ::UInt32 unsigned integer.\n\nNotes\n\nThis function updates the internal state of the PCG instance atomically and returns a random number based on the current state.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.rand_unif_hemisphere-Tuple{PCG}","page":"Home","title":"jujutracer.rand_unif_hemisphere","text":"rand_uniform_hemisphere(pcg::PCG)::Float64\n\nGenerate a random point (x,y,z) on the unit hemisphere using the PCG algorithm.\n\nArguments\n\npcg::PCG: The PCG instance to use for random number generation.\n\nReturns\n\nA tuple (x, y, z) representing the coordinates of the random point on the hemisphere.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.rand_uniform-Tuple{PCG}","page":"Home","title":"jujutracer.rand_uniform","text":"rand_uniform(pcg::PCG)::Float64\n\nGenerate a random floating-point number in the range [0, 1) using the PCG algorithm.\n\nArguments\n\npcg::PCG: The PCG instance to use for random number generation.\n\nReturns\n\nRandom floating-point number in the range [0, 1).\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{Box, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(box::Box, ray::Ray)\n\nCalculate the intersection of a ray and a box.\n\nArguments\n\nbox::Box: The box to be intersected.\nray::Ray: The ray to intersect with the box.\n\nReturns\n\nHitRecord: The hit record of the first intersection, if any.\nnothing: If no intersection occurs.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{CSGDifference, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(D::CSGDifference, ray::Ray)\n\nCalculates the intersection of a ray with the difference of two solid shapes.\n\nArguments\n\nD::CSGDifference: The difference of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersection occurs.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{CSGIntersection, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(I::CSGIntersection, ray::Ray)\n\nCalculates the intersection of a ray with the intersection of two solid shapes.\n\nArguments\n\nI::CSGIntersection: The intersection of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersection occurs.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{CSGUnion, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(U::CSGUnion, ray::Ray)\n\nCalculates the intersection of a ray with the union of two solid shapes.\n\nArguments\n\nU::CSGUnion: The union of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersection occurs.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{Parallelogram, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(S::Parallelogram, r::Ray)\n\nCalculate the intersection of a ray and a plane.\n\nArguments\n\nS::Parallelogram: the parallelogram to be intersected.\nray::Ray: the ray intersecting the triangle.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersections occur.\n\nDifferently from the other shapes, ray_intersection(S::Parallelogram, ray::Ray) incorporates _parallelogram_normal and _point_to_uv\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{Plane, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(p::Plane, r::Ray)\n\nCalculate the intersection of a ray and a plane.\n\nArguments\n\nS::Plane: the plane to be intersected.\nray::Ray: the ray intersecting the plane.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{Rectangle, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(S::Rectangle, r::Ray)\n\nCalculate the intersection of a ray and a plane.\n\nArguments\n\nS::Rectangle: the rectangle to be intersected.\nray::Ray: the ray intersecting the rectangle.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{Sphere, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(s::Sphere, r::Ray)\n\nCalculates the intersection of a ray and a sphere.\n\nArguments\n\nS::Sphere: the sphere to be intersected\nray::Ray: the ray intersecting the sphere\n\nReturns\n\nIf there is an intersection, returns a HitRecord containing the hit information. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{Triangle, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(S::Triangle, r::Ray)\n\nCalculate the intersection of a ray and a triangle.\n\nArguments\n\nS::Triangle: the triangle to be intersected.\nray::Ray: the ray intersecting the triangle.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersections occur.\n\nDifferently from the other shapes, ray_intersection(S::Triangle, ray::Ray) incorporates _triangle_normal and _point_to_uv\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{World, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(W::World, ray::Ray)\n\nCalculates the intersection of a ray with all shapes in the world.\n\nArguments\n\nW::World: the world containing the shapes\nray::Ray: the ray to be intersected with the shapes in the worlds\n\nReturns\n\nIf there is an intersection, returns a HitRecord containing the hit information. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection-Tuple{jujutracer._inf_Cylinder, Ray}","page":"Home","title":"jujutracer.ray_intersection","text":"ray_intersection(s::_inf_Cylinder, r::Ray)\n\nCalculates the intersection of a ray and a sphere.\n\nArguments\n\nS::_inf_Cylinder: the sphere to be intersected\nray::Ray: the ray intersecting the sphere\n\nReturns\n\nIf there is an intersection, returns a HitRecord containing the hit information. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection_list-Tuple{Box, Ray}","page":"Home","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(box::Box, ray::Ray)\n\nCalculate all intersections of a ray with a box.\n\nArguments\n\nbox::Box: The box to be intersected.\nray::Ray: The ray to intersect with the box.\n\nReturns\n\nVector{HitRecord}: A list of hit records for the two intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection_list-Tuple{CSGDifference, Ray}","page":"Home","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(D::CSGDifference, ray::Ray)\n\nCalculates all intersections of a ray with the difference of two solid shapes.\n\nArguments\n\nD::CSGDifference: The difference of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nVector{HitRecord}: A sorted list of hit records for all intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection_list-Tuple{CSGIntersection, Ray}","page":"Home","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(I::CSGIntersection, ray::Ray)\n\nCalculates all intersections of a ray with the intersection of two solid shapes.\n\nArguments\n\nI::CSGIntersection: The intersection of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nVector{HitRecord}: A sorted list of hit records for all intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection_list-Tuple{CSGUnion, Ray}","page":"Home","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(U::CSGUnion, ray::Ray)\n\nCalculates all intersections of a ray with the union of two solid shapes.\n\nArguments\n\nU::CSGUnion: The union of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nVector{HitRecord}: A sorted list of hit records for all intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection_list-Tuple{Sphere, Ray}","page":"Home","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(S::Sphere, ray::Ray)\n\nCalculates all intersections of a ray with a sphere.\n\nArguments\n\nS::Sphere: The sphere to be intersected.\nray::Ray: The ray intersecting the sphere.\n\nReturns\n\nVector{HitRecord}: A list of of the two hit records for the two intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.ray_intersection_list-Tuple{jujutracer._inf_Cylinder, Ray}","page":"Home","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(S::_inf_Cylinder, ray::Ray)\n\nCalculates all intersections of a ray with a sphere.\n\nArguments\n\nS::_inf_Cylinder: The sphere to be intersected.\nray::Ray: The ray intersecting the sphere.\n\nReturns\n\nVector{HitRecord}: A list of of the two hit records for the two intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.read_pfm_image-Tuple{Any}","page":"Home","title":"jujutracer.read_pfm_image","text":"read_pfm_image(io::IO)\n\nRead a PFM image from an input stream.\n\nArguments\n\nio::IO: The input stream from which to read the PFM image.\n\nReturns\n\nhdrimg: The HDR image read from the PFM file.\n\nRaises\n\nInvalidPfmFileFormat: If the PFM file format is invalid or if there are issues reading the file.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.read_pfm_image-Tuple{String}","page":"Home","title":"jujutracer.read_pfm_image","text":"read_pfm_image(filename::String)\n\nRead a PFM image from an input stream.\n\nArguments\n\nfilename::String: The filename ofthe image, expected to be .pfm.\n\nReturns\n\nhdrimg: The HDR image read from the PFM file.\n\nRaises\n\nInvalidPfmFileFormat: If the PFM file format is invalid or if there are issues reading the file.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.save_ldrimage-Tuple{Matrix, String}","page":"Home","title":"jujutracer.save_ldrimage","text":"save_ldrimage(img_matrix::Matrix, filename::String)\n\nSave an LDR image to a file.\n\nArguments\n\nimg_matrix::Matrix: The matrix representation of the image to be saved.\nfilename::String: The name of the file to save the image to, including the file extension (\".png\" or \".jpg\").\n\nReturns\n\nString: The path to the saved file.\n\nRaises\n\nArgumentError: If the file extension is not valid or if the image values are not clamped.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.squared_norm-Tuple{Union{Normal, Vec}}","page":"Home","title":"jujutracer.squared_norm","text":"squared_norm(v::Union{Vec, Normal})\n\nCalculates the squared norm of a vector.\n\nArguments\n\nv::Union{Vec, Normal}: The vector to be processed. Expected to be a struct of 3 values (x, y, z).\n\nReturns\n\nThe squared norm of the vector.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.to_string-Tuple{T} where T<:Union{Normal, Point, Vec}","page":"Home","title":"jujutracer.to_string","text":"to_string(v::T) where {T<:Union{Point, Vec, Normal}}\n\nConverts a Point, Vec, or Normal object to a string representation.\n\nArguments\n\nv::T: The object to be converted. Expected to be a struct of 3 values (x, y, z).\n\nReturns\n\nA string representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.tone_mapping-Tuple{hdrimg}","page":"Home","title":"jujutracer.tone_mapping","text":"tone_mapping(img::hdrimg; a=0.18, lum = nothing, γ = 1.0)\n\nApply tone mapping to the HDR image.\n\nArguments\n\nimg::hdrimg: The HDR image to be tone-mapped.\na::Float64: A positive value to be used in the normalization formula (default is 0.18).\nlum::Float64: The average luminosity of the image. If not provided, it will be calculated using _average_luminosity.\nγ::Float64: The gamma value to be used for correction. Must be a positive number (default is 1.0).\n\nReturns\n\nhdrimg: The tone-mapped HDR image.\n\n\n\n\n\n","category":"method"},{"location":"#jujutracer.write_pfm_image","page":"Home","title":"jujutracer.write_pfm_image","text":"write_pfm_image(img::hdrimg, io, endianness::Bool=true)\n\nWrite a PFM file encodiding the content of an hdrimg\n\nArguments\n\nimg::hdrimg: The HDR image to be written to the PFM file.\nio::IO: The output stream to which the PFM image will be written.\nendianness::Bool: A boolean indicating whether to write the float values in little-endian format (default is true).\n\n\n\n\n\n","category":"function"},{"location":"#jujutracer.write_pfm_image-2","page":"Home","title":"jujutracer.write_pfm_image","text":"write_pfm_image(img::hdrimg, filename::String, endianness::Bool=true)\n\nWrite a PFM file encoding the content of an hdrimg.\n\nArguments\n\nimg::hdrimg: The HDR image to be written to the PFM file.\nfilename::String: The file path where the PFM image will be saved, including the \".pfm\" extension.\nendianness::Bool: A boolean indicating whether to write the float values in little-endian format (default is true).\n\nRaises\n\nInvalidPfmFileFormat: If the file extension is not \".pfm\".\n\n\n\n\n\n","category":"function"}]
}
