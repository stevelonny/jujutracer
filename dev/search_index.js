var documenterSearchIndex = {"docs":
[{"location":"detail/#Detailed-API","page":"Detailed API","title":"Detailed API","text":"","category":"section"},{"location":"detail/#jujutracer.AABB","page":"Detailed API","title":"jujutracer.AABB","text":"struct AABB <: AbstractShape\n\nAxis-Aligned Bounding Box (AABB) for a set of shapes.\n\nFields\n\nS::Vector{AbstractShape}: the vector of shapes contained within the AABB.\nP1::Point: the minimum corner of the AABB.\nP2::Point: the maximum corner of the AABB.\n\nConstructor\n\nAABB(S::Vector{AbstractShape}): creates an AABB for the shapes in S, calculating the minimum and maximum corners based on the bounding boxes of the shapes.\nAABB(S::Vector{AbstractShape}, P1::Point, P2::Point): creates an AABB with the specified minimum and maximum corners P1 and P2 for the shapes in S.\nAABB(csg::Union{CSGDifference, CSGUnion, CSGIntersection}): creates an AABB for a CSG shape, extracting the shapes and their bounding box.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.AbstractCamera","page":"Detailed API","title":"jujutracer.AbstractCamera","text":"abstract type AbstractCamera\n\nAbstact type AbstractCamera\n\nAbstractCamera(u, v) returns a ray fired in the pixel (u, v) of the screen\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.AbstractLight","page":"Detailed API","title":"jujutracer.AbstractLight","text":"abstract type AbstractLight\n\nAbstract type for light sources. Made concrete by LightSource and SpotLight.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.AbstractShape","page":"Detailed API","title":"jujutracer.AbstractShape","text":"abstract type AbstractShape\n\nAbstract type for all shapes. Not guaranteed to be water-tight. Cannot be used to create CSG shapes. See also AbstractSolid.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.AbstractSolid","page":"Detailed API","title":"jujutracer.AbstractSolid","text":"abstract type AbstractSolid <: AbstractShape\n\nAbstract type for solid shapes. Considered water-tight. Can be used to create CSG shapes. Made concrete by Sphere, Box, Cylinder, Cone, CSGUnion, CSGDifference, and CSGIntersection.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.AbstractTransformation","page":"Detailed API","title":"jujutracer.AbstractTransformation","text":"AbstractTransformation\n\nAn abstract type that serves as a base for defining various geometric transformations. Made concrete by Transformation, Translation, Scaling, Rx, Ry, and Rz.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.AbstractTransformation-Tuple{Normal}","page":"Detailed API","title":"jujutracer.AbstractTransformation","text":"(t::AbstractTransformation)(n::Normal)\n\nApplies the transformation to a Normal.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.AbstractTransformation-Tuple{Point}","page":"Detailed API","title":"jujutracer.AbstractTransformation","text":"(t::AbstractTransformation)(p::Point)\n\nApplies the transformation to a Point.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.AbstractTransformation-Tuple{Vec}","page":"Detailed API","title":"jujutracer.AbstractTransformation","text":"(t::AbstractTransformation)(v::Vec)\n\nApplies the transformation to a Vec.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.Box","page":"Detailed API","title":"jujutracer.Box","text":"struct Box <: AbstractSolid\n\nAn axis-aligned box (rectangular cuboid) defined by two opposite corners.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the box.\nP1::Point: One corner of the box (minimum x, y, z).\nP2::Point: The opposite corner of the box (maximum x, y, z).\nMat::Material: The material of the box.\n\nConstructors\n\nBox(): Creates a new box with default transformation and material.\nBox(Tr::AbstractTransformation): Creates a new box with the specified transformation and default material.\nBox(P1::Point, P2::Point): Creates a new box with the specified corners and default transformation and material.\nBox(P1::Point, P2::Point, Mat::Material): Creates a new box with the specified corners and material.\nBox(Tr::AbstractTransformation, P1::Point, P2::Point): Creates a new box with the specified transformation and corners.\nBox(Tr::AbstractTransformation, P1::Point, P2::Point, Mat::Material): Creates a new box with the specified transformation, corners, and material.\nBox(Mat::Material): Creates a new box with the default transformation and the specified material.\nBox(Tr::AbstractTransformation, Mat::Material): Creates a new box with the specified transformation and material.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.CSGDifference","page":"Detailed API","title":"jujutracer.CSGDifference","text":"struct CSGDifference <: AbstractSolid\n\nRepresents the difference of two solid shapes.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the difference.\nSh1::AbstractSolid, Sh2::AbstractSolid: The two solid shapes where Sh1 - Sh2 is computed.\n\nSee also\n\nCSGUnion: Represents the union of two solid shapes.\nCSGIntersection: Represents the intersection of two solid shapes.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.CSGIntersection","page":"Detailed API","title":"jujutracer.CSGIntersection","text":"struct CSGIntersection <: AbstractSolid\n\nRepresents the intersection of two solid shapes.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the intersection.\nSh1::AbstractSolid, Sh2::AbstractSolid: The two solid shapes being intersected.\n\nSee also\n\nCSGUnion: Represents the union of two solid shapes.\nCSGDifference: Represents the difference of two solid shapes.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.CSGUnion","page":"Detailed API","title":"jujutracer.CSGUnion","text":"struct CSGUnion <: AbstractSolid\n\nRepresents the union of two solid shapes.\n\nFields\n\nTr::AbstractTransformation: The transformation applied to the union.\nSh1::AbstractSolid, Sh2::AbstractSolid: The two solid shapes being united.\n\nSee also\n\nCSGDifference: Represents the difference of two solid shapes.\nCSGIntersection: Represents the intersection of two solid shapes.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.CheckeredPigment","page":"Detailed API","title":"jujutracer.CheckeredPigment","text":"CheckeredPigment(col::Int32, row::Int32, dark::RGB, bright::RGB)\n\nCheckered pigment for a Shape, subdiveded in row rows and col columns with alternate dark and bright color\n\nFields\n\ncol number of horizontal subdivisions\nrow number of vertical subdivisions\ndark color of the dark squares\nbright color of the bright squares\n\nFunctional Usage\n\nCheckeredPigment(p::SurfacePoint) return the RGB associated to the (u, v) coordinates of the SurfacePoint \n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Circle","page":"Detailed API","title":"jujutracer.Circle","text":"struct Circle <: AbstractShape\n\nA unit circle in the xy-plane, centered at the origin.\n\nFields\n\nTr::AbstractTransformation: the transformation applied to the circle.\nMat::Material: the material of the shape.\n\nConstructors\n\nCircle(): Creates a new circle with default transformation and material.\nCircle(Tr::AbstractTransformation): Creates a new circle with the specified transformation and default material.\nCircle(Mat::Material): Creates a new circle with the default transformation and the specified material.\nCircle(Tr::AbstractTransformation, Mat::Material): Creates a new circle with the specified transformation and material.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Cone","page":"Detailed API","title":"jujutracer.Cone","text":"struct Cone <: AbstractSolid\n\nA cone of unitary radiuos and height resting on the xy plane. This structure is a subtype of AbstractSolid.\n\nFields\n\nTr::Transformation: the transformation applied to the sphere.\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Cylinder","page":"Detailed API","title":"jujutracer.Cylinder","text":"struct Cylinder <: AbstractSolid\n\nA cylinder of unitary radiuos and height centered in the origin. This structure is a subtype of AbstractSolid.\n\nFields\n\nTr::Transformation: the transformation applied to the sphere.\nMat::Material: the material of the shape\n\nConstructors\n\nCylinder(): Creates a new cylinder with default transformation and material.\nCylinder(Tr::AbstractTransformation): Creates a new cylinder with the specified transformation and default material.\nCylinder(Mat::Material): Creates a new cylinder with the default transformation and the specified material.\nCylinder(Tr::AbstractTransformation, Mat::Material): Creates a new cylinder with the specified transformation and material.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.DiffusiveBRDF","page":"Detailed API","title":"jujutracer.DiffusiveBRDF","text":"DiffusiveBRDF(Pigment::AbstractPigment)\n\nDiffusive BRDF with reflective pigment Pigment.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Flat","page":"Detailed API","title":"jujutracer.Flat","text":"Flat(world::World)\n\nFlat renderer of the scene. Returns the Emition pigment of the hitten shapes\n\nFields\n\nworld::World the world containing the scene\n\nFunctional Usage\n\nFlat(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.HitRecord","page":"Detailed API","title":"jujutracer.HitRecord","text":"HitRecord(world_point::Point, normal::Normal, surface_point::SurfacePoint, t::Float64, ray::Ray)\n\nInformation about an intersection\n\nFields\n\nworld_P::Point the point in the world where the ray hit\nnormal::Normal the normal vector at the point of intersection\nsurface_P::SurfacePoint the point on the surface where the ray hit\nt::Float64 the distance from the ray origin to the hit point\nray::Ray the ray that hit the surface\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.ImagePigment","page":"Detailed API","title":"jujutracer.ImagePigment","text":"ImagePigment(img::hdrimg)\n\nPrint the image img as pigment of the surface\n\nFields\n\nimg::hdrimg the image in hdr format\n\nFunctional Usage\n\nImagePigment(p::SurfacePoint) return the RGB of to the (u, v) coordinates of the SurfacePoint associated to the corresponding element of img\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.ImageTracer","page":"Detailed API","title":"jujutracer.ImageTracer","text":"struct ImageTracer\n\nConvenient struct to hold the hdrimage and the camera.\n\nFields\n\nimg::hdrimg: The HDR image to be traced.\ncamera::AbstractCamera: The camera used for tracing rays. Can be either Orthogonal or Perspective.\n\nConstructor\n\nImageTracer(): Creates a new ImageTracer with a default HDR image and an orthogonal camera.\nImageTracer(img::hdrimg, camera::AbstractCamera): Creates a new ImageTracer with the specified HDR image and camera.\n\nFunctional Usage\n\nImageTracer(fun::Function): tracing the image with fun renderer.\nImageTracer(fun::Function, AA::Int64, pcg::PCG): tracing the image with fun renderer and Anti-Aliasing method with AA^2 subdivision in the pixel.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.ImageTracer-Tuple{Function, Int64, PCG}","page":"Detailed API","title":"jujutracer.ImageTracer","text":"(it::ImageTracer)(fun::Function, AA::Int64, pcg::PCG)\n\nApply a function to each pixel in the image with Anti-Aliasing (AA) leveraging stratified random sampling.\n\nArguments\n\nfun::Function: Must be a function that takes a ::Ray as input and returns a color (ColorTypes.RGB).\nAA::Int64: The Anti-Aliasing factor, which determines the number of samples per pixel (AA^2 samples).\npcg::PCG: A pseudo-random number generator for generating random offsets in the pixel.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ImageTracer-Tuple{Function}","page":"Detailed API","title":"jujutracer.ImageTracer","text":"(it::ImageTracer)(fun::Function)\n\nApply a function to each pixel in the image. Leverage parallel processing for performance.\n\nArguments\n\nfun::Function: Must be a function that takes a ::Ray as input and returns a color (ColorTypes.RGB).\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ImageTracer-Tuple{Int64, Int64}","page":"Detailed API","title":"jujutracer.ImageTracer","text":"(it::ImageTracer)(col::Int, row::Int; u_pixel::Float64 = 0.5, v_pixel::Float64 = 0.5)\n\nReturn the ray cast from the camera through the pixel at (col, row) in the image.\n\nArguments\n\ncol_pixel::Int, row_pixel::Int: The column and row indexes of the pixel in the image.\nu_pixel::Float64, v_pixel::Float64: The pixel offset in the u and v directions (default is 0.5, center of the pixel).\n\nReturns\n\nRay: The ray cast from the camera through the specified pixel.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.InvalidPfmFileFormat","page":"Detailed API","title":"jujutracer.InvalidPfmFileFormat","text":"InvalidPfmFileFormat <: Exception\n\nException raised when the PFM file format is invalid or cannot be read.\n\nFields\n\nerror_message::String: The error message describing the issue.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.LightSource","page":"Detailed API","title":"jujutracer.LightSource","text":"struct LightSource\n\nA struct representing a point light source.\n\nFields\n\nposition::Point: the position of the light source in 3D space.\nemission::RGB: the color of the light emitted by the source.\nscale::Float64: the scale factor for the light source, affecting its intensity.\n\nConstructors\n\nLightSource(position::Point, emission::RGB=RGB(1.0, 1.0, 1.0), scale::Float64=1.0): Creates a new light source with the specified position, emission color, and scale factor.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Material","page":"Detailed API","title":"jujutracer.Material","text":"struct Material\n\nFields\n\nEmition::AbstractPigment: the pigement with which the radiation is emitted.\nBRDF::AbstractBRDF: the BRDF of the material.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Normal","page":"Detailed API","title":"jujutracer.Normal","text":"Normal(x::Float64, y::Float64, z::Float64)\n\nStruct representing a unit vector (normal) in 3D space.\n\nFields\n\nx::Float64,y::Float64,z::Float64: Coordinates.\n\nMethods\n\nNormal(v::Vec): Create a Normal from a Vec.\nNormal(x::Float64, y::Float64, z::Float64): Create a Normal from x, y, z coordinates.\n\nThrows\n\nArgumentError: If the vector is zero.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.OnOff","page":"Detailed API","title":"jujutracer.OnOff","text":"OnOff(world::World)\n\nOnOff renderer of the scene. Returns white if the ray hits something, balck otherwise\n\nFields\n\nworld::World the world containing the scene\nbackground_color::RGB the color of the background when the ray doesn't hit anything\nforeground_color::RGB the color of the foreground when the ray hits something\n\nFunctional Usage\n\nOnOff(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Orthogonal","page":"Detailed API","title":"jujutracer.Orthogonal","text":"Orthogonal\n\nOrthogonal camera type\n\nFields\n\nt::Transformation the transformation related to the camera's standing\na_ratio::Float64 aspect ratio of the screen of the camera\n\nConstructor\n\nOrthogonal() creates an orthogonal camera with Identity Transformation and a 16:9 aspect ratio\nOrtoghonal(t = trans, a_ratio = a) creates an orthogonal camera with trans Transformation and an a aspect ratio\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Parallelogram","page":"Detailed API","title":"jujutracer.Parallelogram","text":"struct Parallelogram <: AbstractShape\n\nParallelogram\n\n   C-----p\n  /     /\n /     /\nA-----B\n\nFields\n\nt::Transformation: the transformation applied to the Parallelogram.\nA, B, C::Point: the vertices defining the quadrilateral's \nMat::Material: the material of the shape\n\nConstructor\n\nParallelogram(): creates a parallelogram with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nParallelogram(Tr::AbstractTransformation): creates a parallelogram with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nParallelogram(Mat::Material): creates a parallelogram with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nParallelogram(Tr::AbstractTransformation, Mat::Material): creates a parallelogram with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nParallelogram(A::Point, B::Point, C::Point): creates a parallelogram with Identity Transformation and vertices A, B, C and a default material.\nParallelogram(A::Point, B::Point, C::Point, Mat::Material): creates a parallelogram with Identity Transformation and vertices A, B, C and a Mat material.\nParallelogram(A::Point, AB::Vec, AC::Vec): creates a parallelogram with Identity Transformation and vertices A, A + AB, A + AC and a default material.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.PathTracer","page":"Detailed API","title":"jujutracer.PathTracer","text":"PathTracer(world::World, backg::RGB, rnd::PCG, n_rays::Int64, depth::Int64, russian::Int64)\n\nPath Tracer renderer of the scene.\n\nFields\n\nworld::World: the world containing the scene\nbackg::RGB: the background color when the ray doesn't intersect anything\nrnd::PCG: the random number generator\nn_rays::Int64: the number of rays fired from the hitten point\ndepth::Int64: the maximum depth to be reached by a ray\nrussian::Int64: number of iteration before playing with Russian Roulet\n\nFunctional Usage\n\nPathTracer(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Perspective","page":"Detailed API","title":"jujutracer.Perspective","text":"Perspective\n\nPerspective camera type\n\nFields\n\nt::Transformation the transformation related to the camera's standing\na_ratio::Float64 aspect ratio of the screen of the camera\n\nConstructor\n\nPerspective() creates a perspective camera with Identity Transformation, a 16:9 aspect ratio placed in (-1, 0, 0)\nPerspective(d = dist, t = trans, a_ratio = a) creates a perspective camera with trans Transformation, an a aspect ratio placed in (-d, 0, 0)\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Plane","page":"Detailed API","title":"jujutracer.Plane","text":"struct Plane <: AbstractShape\n\nA plane. This structure is a subtype of AbstractShape.\n\nFields\n\nt::Transformation: the transformation applied to the plane\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Point","page":"Detailed API","title":"jujutracer.Point","text":"Point(x::Float64, y::Float64, z::Float64)\n\nStruct representing a point in 3D space.\n\nFields\n\nx::Float64,y::Float64,z::Float64: Coordinates.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.PointLight","page":"Detailed API","title":"jujutracer.PointLight","text":"PointLight(world::World, background::RGB, ambient::RGB, max_depth::Int64)\n\nPointLight renderer of the scene. Backtraces the light from the point light sources.\n\nFields\n\nworld::World: the world containing the scene. Must contain at least one light source\nbackground_color::RGB: the color of the background when the ray doesn't hit anything\nambient_color::RGB: the ambient color of the scene\nmax_depth::Int64: the maximum depth of the ray tracing\n\nFunctional Usage\n\nPointLight(ray::Ray) functional renderer on a ray\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Ray","page":"Detailed API","title":"jujutracer.Ray","text":"Ray(origin::Point, dir::Vec, tmin::Float=1e-5, tmax::Float=Inf, depth::Int=0)\n\nA struct representing a ray in 3D space.\n\nFields\n\norigin::Point: The origin point of the ray.\ndir::Vec: The direction vector of the ray.\ntmin::Float: The minimum distance along the ray (default is le-5).\ntmax::Float: The maximum distance along the ray (default is Inf).\ndepth::Int: The depth of the ray (default is 0).\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Ray-Tuple{Float64}","page":"Detailed API","title":"jujutracer.Ray","text":"(r::Ray)(t::Float64)\n\nReturn the point along the ray at distance t from the origin.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.Rectangle","page":"Detailed API","title":"jujutracer.Rectangle","text":"struct Rectangle <: AbstractShape\n\n1x1 Rectangle on xy plane, centered in the origin\n\nFields\n\nt::Transformation: the transformation applied to the plane\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Rx","page":"Detailed API","title":"jujutracer.Rx","text":"struct Rx <: AbstractTransformation\n\nRepresents a rotation transformation around the x-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRx(θ): Creates an Rx instance for a given rotation θ (in radians).\n\nSee also\n\nRy: For rotation around the y-axis.\nRz: For rotation around the z-axis.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Ry","page":"Detailed API","title":"jujutracer.Ry","text":"struct Ry <: AbstractTransformation\n\nRepresents a rotation transformation around the y-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRy(θ): Creates an Ry instance for a given rotation θ (in radians).\n\nSee also\n\nRx: For rotation around the x-axis.\nRz: For rotation around the z-axis.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Rz","page":"Detailed API","title":"jujutracer.Rz","text":"struct Rz <: AbstractTransformation\n\nRepresents a rotation transformation around the z-axis in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nRz(θ): Creates an Rz instance for a given rotation θ (in radians).\n\nSee also\n\nRx: For rotation around the x-axis.\nRy: For rotation around the y-axis.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Scaling","page":"Detailed API","title":"jujutracer.Scaling","text":"struct Scaling <: AbstractTransformation\n\nRepresents a scaling transformation in 3D space. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructor\n\nScaling(x::Float64, y::Float64, z::Float64):   Creates aScalinginstance with scaling factorsx,y, andzalong the x, y, and z axes, respectively.   Throws anArgumentError` if any of the scaling factors are zero.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.SpecularBRDF","page":"Detailed API","title":"jujutracer.SpecularBRDF","text":"SpecularBRDF(Pigment::AbstractPigment)\n\nSpecular BRDF with reflective pigment Pigment.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Sphere","page":"Detailed API","title":"jujutracer.Sphere","text":"struct Sphere <: AbstractSolid\n\nA sphere. Unit radius sphere centered at the origin. This structure is a subtype of AbstractSolid.\n\nFields\n\nt::Transformation: the transformation applied to the sphere.\nMat::Material: the material of the shape\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.SpotLight","page":"Detailed API","title":"jujutracer.SpotLight","text":"struct SpotLight <: AbstractLight\n\nA struct representing a spotlight source.\n\nFields\n\nposition::Point: the position of the spotlight in 3D space.\ndirection::Vec: the direction in which the spotlight is pointing.\nemission::RGB: the color of the light emitted by the spotlight.\nscale::Float64: the scale factor for the spotlight, affecting its intensity.\ncos_total::Float64: the cosine of the angle that defines the total light cone.\ncos_falloff::Float64: the cosine of the angle that defines the falloff region of the spotlight.\ncos_start::Float64: the cosine of the angle that defines the start of the falloff region.\n\nConstructors\n\nSpotLight(position::Point, direction::Vec, emission::RGB=RGB(1.0, 1.0, 1.0), scale::Float64=100.0, cos_total::Float64=0.9, cos_falloff::Float64=0.93, cos_start::Float64=0.95): Creates a new spotlight with the specified parameters.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.SurfacePoint","page":"Detailed API","title":"jujutracer.SurfacePoint","text":"struct SurfacePoint\n\nA struct representing a point on the surface of a shape.\n\nFields\n\nu::Float64, `v::Float64: the (u,v) coordinates of the point on the surface.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Transformation","page":"Detailed API","title":"jujutracer.Transformation","text":"struct Transformation <: AbstractTransformation\n\nRepresents a transformation in 3D space with homogeneous coordinates. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse of the transformation matrix.\n\nConstructors\n\nTransformation(): Creates an identity transformation where M and inv are both 4x4 identity matrices.\nTransformation(M::Matrix{Float64}, inv::Matrix{Float64}): Creates a transformation with the given M and inv matrices.\nTransformation(M::Matrix{Float64}, inv::Matrix{Float64}, unsafe::Unsafe): Creates a transformation with the given M and inv matrices, without veryfing the inputs.\n\nThrows an ArgumentError if:\n\nM or inv are not 4x4 matrices.\nThe last element of M or inv is not 1.0.\nM and inv are not inverses of each other.\n\nNotes\n\nThe M and inv matrices must satisfy the following conditions:\n\nBoth must be 4x4 matrices.\nThe last element of both matrices must be 1.0.\nThe product of M and inv must be approximately equal to the 4x4 identity matrix.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Translation","page":"Detailed API","title":"jujutracer.Translation","text":"struct Translation <: AbstractTransformation\n\nRepresents a translation in 3D space with homogeneous coordinates. This structure is a subtype of AbstractTransformation.\n\nFields\n\nM::Matrix{Float64}: The 4x4 transformation matrix.\ninv::Matrix{Float64}: The 4x4 inverse transformation matrix.\n\nConstructors\n\nTranslation(dx::Float64, dy::Float64, dz::Float64):  Creates a Translation object with translation offsets dx, dy, and dz along the x, y, and z axes, respectively.\nTranslation(v::Vec): Creates a Translation object using a Vec object.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Triangle","page":"Detailed API","title":"jujutracer.Triangle","text":"struct Triangle <: AbstractShape\n\nTriangle.\n\nFields\n\nt::Transformation: the transformation applied to the triangle\nA, B, C::Point: the vertices of the triangle\nMat::Material: the material of the shape\n\nConstructor\n\nTriangle(): creates a triangle with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nTriangle(Tr::AbstractTransformation): creates a triangle with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a default material.\nTriangle(Mat::Material): creates a triangle with Identity Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nTriangle(Tr::AbstractTransformation, Mat::Material): creates a triangle with Tr Transformation and vertices (0,0,0), (1,0,0), (0,1,0) and a Mat material.\nTriangle(A::Point, B::Point, C::Point): creates a triangle with Identity Transformation and vertices A, B, C and a default material.\nTriangle(A::Point, B::Point, C::Point, Mat::Material): creates a triangle with Identity Transformation and vertices A, B, C and a Mat material.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.UniformPigment","page":"Detailed API","title":"jujutracer.UniformPigment","text":"UniformPigment()\n\nUniform Pigment for Shapes\n\nFields\n\ncolor::RBG the uniform color\n\nFunctional Usage\n\nUniformPigment(p::SurfacePoint) return the RGB associated to the (u, v) coordinates of the SurfacePoint\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Unsafe","page":"Detailed API","title":"jujutracer.Unsafe","text":"struct Unsafe\n\nA singleton struct used to indicate unsafe operations in transformations. See also Transformation and _unsafe_inverse.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.Vec","page":"Detailed API","title":"jujutracer.Vec","text":"Vec(x::Float64, y::Float64, z::Float64)\n\nA struct representing a vector in 3D space.\n\nFields\n\nx::Float64,y::Float64,z::Float64: Coordinates.\n\nMethods\n\nVec(n::Normal): Create a Vec from a Normal.\nVec(p::Point): Create a Vec from a Point.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.World","page":"Detailed API","title":"jujutracer.World","text":"struct World\n\nA struct representing a collection of shapes (and lights) in a 3D world.\n\nFields\n\nshapes::Vector{AbstractShape}: the vector containing the shapes in the world.\nlights::Vector{AbstractLight}: the vector containing the light sources in the world.\n\nConstructor\n\nWorld(): creates a new World with an empty vector of shapes.\nWorld(S::Vector{AbstractShape}): creates a new World with the specified vector of shapes. Lights are initialized to an empty vector.\nWorld(S::Vector{AbstractShape}, L::Vector{AbstractLight}): creates a new World with the specified vector of shapes and light sources.\n\nSee also\n\nAbstractShape: the abstract type for all shapes.\nSphere: a concrete implementation of AbstractShape representing a sphere.\nPlane: a concrete implementation of AbstractShape representing a plane.\n\n\n\n\n\n","category":"type"},{"location":"detail/#jujutracer.hdrimg","page":"Detailed API","title":"jujutracer.hdrimg","text":"hdrimg(w::Int, h::Int)\n\nA struct representing a high dynamic range image (HDR image). Getter and setter methods are defined for accessing and modifying pixel values. Access is done using 0-based indexing, so the first pixel is at (0, 0): img[0, 0]; while the bottom right pixel is at (w-1, h-1): img[w-1, h-1].\n\n    img = [ (0  , 0)   (0  , 1) ... (0  , w-1)\n            (1  , 0)   (1  , 1) ... (1  , w-1)\n             ...\n            (h-1, 1)   (h-1, 2) ... (h-1, w-1) ]\n\nFields\n\nimg::Matrix{RGB}: A matrix of RGB values representing the HDR image. Not intedend to be accessed directly.\nw::Int64: The width of the image in pixels.\nh::Int64: The height of the image in pixels.\n\n\n\n\n\n","category":"type"},{"location":"detail/#Base.:≈-Tuple{jujutracer.AbstractTransformation, jujutracer.AbstractTransformation}","page":"Detailed API","title":"Base.:≈","text":"≈(a::Union{Transformation, Translation, Scaling, Rx, Ry, Rz}, b::Union{Transformation, Translation, Scaling, Rx, Ry, Rz})\n\nDefines an approximate equality operator ≈ for geometric transformations.  Two transformations a and b are considered approximately equal if both their transformation matrices (M) and their inverses (inv) are approximately equal.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.:×-Tuple{Union{Normal, Vec}, Union{Normal, Vec}}","page":"Detailed API","title":"jujutracer.:×","text":"a × b\n\nReturn wedge product (times) between Vec or Normal as a Vec.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.:⊙-Tuple{Any, Any}","page":"Detailed API","title":"jujutracer.:⊙","text":"⊙(a, b)\n\nComposition of two transformations, where b is the first acting on the object and a the second.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.:⋅-Tuple{Union{Normal, Vec}, Union{Normal, Vec}}","page":"Detailed API","title":"jujutracer.:⋅","text":"a ⋅ b\n\nReturn scalar product (cdot) between Vec or Normal.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._LFD-Tuple{Point, Point}","page":"Detailed API","title":"jujutracer._LFD","text":"_LFD(P1::Point, P2::Point)\n\nReturn the corner of the box with the minimum x, y, z coordinates (Left, Front, Down).\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._RBU-Tuple{Point, Point}","page":"Detailed API","title":"jujutracer._RBU","text":"_RBU(P1::Point, P2::Point)\n\nReturn the corner of the box with the maximum x, y, z coordinates (Right, Back, Up).\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._RGBluminosity","page":"Detailed API","title":"jujutracer._RGBluminosity","text":"_RGBluminosity(color, type = \"LF\")\n\nCalculate the luminosity of a color using different methods.\n\nArguments\n\ncolor: The RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\ntype: The type of luminosity calculation to perform. Options are:\n'LF' : Luminosity function (default),\n'M' : Mean luminosity,\n'W' : Weighted luminosity,\n'D' : Euclidean distance luminosity.\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"function"},{"location":"detail/#jujutracer._average_luminosity-Tuple{hdrimg}","page":"Detailed API","title":"jujutracer._average_luminosity","text":"_average_luminosity(img::hdrimg; type = \"LF\", delta = 0.0001)\n\nReturn the average luminosity of an HDR image, given the type of luminosity calculation to be used and delta to avoid.\n\nArguments\n\nimg::hdrimg: The HDR image for which to calculate the average luminosity.\ntype::String: The type of luminosity calculation to be used. Options are:\nLF: Luminosity function (default)\nM: Mean luminosity\nW: Weighted luminosity\nD: Euclidean distance luminosity\ndelta::Float64: A small value to avoid log(0) for black pixels (default is 0.0001).\n\nReturns\n\nFloat64: The average luminosity of the HDR image.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._circle_normal-Tuple{Point, Vec}","page":"Detailed API","title":"jujutracer._circle_normal","text":"_circle_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the circle.\n\nArguments\n\np::Point: the point on the circle.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the circle's surface at the point.\n\nThrows\n\nArgumentError: if the point is outside the circle.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._circle_point_to_uv-Tuple{Point}","page":"Detailed API","title":"jujutracer._circle_point_to_uv","text":"_circle_point_to_uv(p::Point)\n\nHelper function to convert a point on the circle to UV coordinates.\n\nArguments\n\np::Point: the point on the circle.\n\nReturns\n\nSurfacePoint: the UV coordinates of the point on the circle.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._clamp_img!-Tuple{hdrimg}","page":"Detailed API","title":"jujutracer._clamp_img!","text":"_clamp_img!(hdr::hdrimg)\n\nClamp the HDR image values to the range [0, 1] using the formula:\n\nR_i  fracR_i1+R_i\n\nArguments\n\nhdr::hdrimg: The HDR image to be clamped.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._cone_normal-Tuple{Point, Vec}","page":"Detailed API","title":"jujutracer._cone_normal","text":"_cone_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the cone.\n\nArguments\n\np::Point: the point on the cone.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the cone's surface at the point.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._cylinder_normal-Tuple{Point, Vec}","page":"Detailed API","title":"jujutracer._cylinder_normal","text":"_cylinder_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the cylinder.\n\nArguments\n\np::Point: the point on the cylinder.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the cylinder's surface at the point.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._light_modulation-Tuple{LightSource, HitRecord}","page":"Detailed API","title":"jujutracer._light_modulation","text":"_light_modulation(light::LightSource, repo::HitRecord)\n\nCalculate the light modulation for a point light source at a given hit record.\n\nArguments\n\nlight::LightSource: the light source to calculate modulation for.\nrepo::HitRecord: the hit record containing the intersection point and normal.\n\nReturns\n\nRGB: the modulated light color at the hit point.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._light_modulation-Tuple{SpotLight, HitRecord}","page":"Detailed API","title":"jujutracer._light_modulation","text":"_light_modulation(spot::SpotLight, repo::HitRecord)\n\nCalculate the light modulation for a spotlight at a given hit record.\n\nArguments\n\nspot::SpotLight: the spotlight to calculate modulation for.\nrepo::HitRecord: the hit record containing the intersection point and normal.\n\nReturns\n\nRGB: the modulated light color at the hit point.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._lumi_D-Tuple{Any}","page":"Detailed API","title":"jujutracer._lumi_D","text":"_lumi_D(color)\n\nEuclidean distance luminosity function.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._lumi_Func-Tuple{Any}","page":"Detailed API","title":"jujutracer._lumi_Func","text":"_lumi_Func(color)\n\nLuminosity function according to the formula: fracmax(rgb) + min(rgb)2.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._lumi_mean-Tuple{Any}","page":"Detailed API","title":"jujutracer._lumi_mean","text":"_lumi_mean(color)\n\nBasic mean luminosity function.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe mean luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._lumi_weighted-Tuple{Any}","page":"Detailed API","title":"jujutracer._lumi_weighted","text":"_lumi_weighted(color)\n\nWeighted mean luminosity function according to CCIR 601.\n\nArguments\n\nThe RGB color to be processed. Expected to be a struct of 3 values (r, g, b).\n\nReturns\n\nThe luminosity value of the pixel.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._mat-Tuple{Vec, Vec, Vec}","page":"Detailed API","title":"jujutracer._mat","text":"_mat(a::Vec, b::Vec, c::Vec)\n\nReturns a Matrix build with the transposed Vectors aᵗ, bᵗ and cᵗ.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._normalize_img!-Tuple{hdrimg}","page":"Detailed API","title":"jujutracer._normalize_img!","text":"_normalize_img!(img::hdrimg: a::T, std::T) where {T<:Real, N}\n\nNormalize an image by using\n\nR_i  R_i  fracR_il\n\nArguments\n\nimg::hdrimg: The HDR image to be normalized.\na::T: A positive value to be used in the normalization formula.\nlum::T: The average luminosity of the image. If not provided, it will be calculated using _average_luminosity.\n\nRaises\n\nArgumentError: If a is not a positive number or if lum is not a number.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._parse_endianness-Tuple{String}","page":"Detailed API","title":"jujutracer._parse_endianness","text":"_parse_endianness(endian::String)\n\nParse endianness of the PFM file from a string.\n\nArguments\n\nendian::String: The string representation of the endianness, expected to be \"±1.0\".\n\nReturns\n\nBool: Returns true if the endianness is little-endian, false if big-endian.\n\nRaises\n\nInvalidPfmFileFormat: If the endianness value is invalid or missing.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._parse_image_size-Tuple{String}","page":"Detailed API","title":"jujutracer._parse_image_size","text":"_parse_image_size(line::String)\n\nRead image size from a string.\n\nArguments\n\nline::String: The string representation of the image size, expected to be a couple of ints \"width height\".\n\nReturns\n\nTuple{Int, Int}: A tuple containing the width and height of the image.\n\nRaises\n\nInvalidPfmFileFormat: If the image size specification is invalid or if the width/height values are not integers.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._plane_normal-Tuple{Point, Vec}","page":"Detailed API","title":"jujutracer._plane_normal","text":"_plane_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the plane\n\nArguments\n\np::Point: the point on the plane.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the plane's surface at the point.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._point_to_uv-Tuple{Box, Point, Normal}","page":"Detailed API","title":"jujutracer._point_to_uv","text":"_point_to_uv(box::Box, p::Point, norm::Normal)\n\nCalculate the UV coordinates of a point on the surface of a box, using the surface normal to determine which face is being mapped. The UV mapping follows a cube-unwrapping scheme:\n\n    +----+------+-----+----+\n    |xxxx| Top  |xxxxxxxxxx|\n    |xxxx| (Y+) |xxxxxxxxxx| \n2/3 +----+------+-----+----+\n    |Left|Front |Right|Back|\n    |(X-)|(Z+)  |(X+) |(Z-)|\n1/3 +----+------+-----+----+\n    |xxxx|Bottom|xxxxxxxxxx|\n    |xxxx| (Y-) |xxxxxxxxxx|\n    +----+------+-----+----+\n\nArguments\n\nbox::Box: The box shape.\np::Point: The point on the box surface (in local box coordinates).\nnorm::Normal: The untransformed normal at the point, used to determine which face is being mapped.\n\nReturns\n\nSurfacePoint: The UV coordinates (u, v) of the point on the box surface.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._point_to_uv-Tuple{Circle, Point}","page":"Detailed API","title":"jujutracer._point_to_uv","text":"_point_to_uv(S::Circle, p::Point)\n\nCalculate the UV coordinates of a point on the circle.\n\nArguments\n\nS::Circle: the circle.\np::Point: the point on the circle.\n\nReturns\n\nSurfacePoint: the UV coordinates of the point on the circle.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._point_to_uv-Tuple{Cone, Point}","page":"Detailed API","title":"jujutracer._point_to_uv","text":"_point_to_uv(S::Cone, p::Point)\n\nCalculate the UV coordinates of a point on the cone.\n\nArguments\n\nS::Cone the cone.\np::Point the point on the cone.\n\nReturns\n\nSurfacePoint: the UV coordinates of the point on the cone.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._point_to_uv-Tuple{Cylinder, Point}","page":"Detailed API","title":"jujutracer._point_to_uv","text":"_point_to_uv(S::Cylinder, p::Point)\n\nCalculate the UV coordinates of a point on the cylinder.\n\nArguments\n\nS::Cylinder the cylinder.\np::Point the point on the cylinder.\n\nReturns\n\nSurfacePoint: the UV coordinates of the point on the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._point_to_uv-Tuple{Plane, Point}","page":"Detailed API","title":"jujutracer._point_to_uv","text":"_point_to_uv(S::Plane, p::Point)\n\nCalculate the UV coordinates of a point on the plane in PBC\n\nArguments\n\np::Point: the point on the plane\n\nReturns\n\nSurfacePoint: the UV coordinates of the point in PBC\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._point_to_uv-Tuple{Rectangle, Point}","page":"Detailed API","title":"jujutracer._point_to_uv","text":"pointto_uv(S::Rectangle, p::Point)\n\nCalculate the UV coordinates of a point on the plane in PBC\n\nArguments\n\np::Point: the point on the rectangle\n\nReturns\n\nSurfacePoint: the UV coordinates of the point in PBC\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._point_to_uv-Tuple{Sphere, Point}","page":"Detailed API","title":"jujutracer._point_to_uv","text":"_point_to_uv(S::Sphere, p::Point)\n\nCalculate the UV coordinates of a point on the sphere.\n\nArguments\n\nS::Sphere the Sphere\np::Point the point on the sphere\n\nReturns\n\nSurfacePoint: the UV coordinates of the point on the sphere\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._read_float-Tuple{IO, Any}","page":"Detailed API","title":"jujutracer._read_float","text":"_read_float(io::IO, is_little_endian)\n\nRead a Float32 value by interpreting 4 bytes with the correct endianness from a buffer.\n\nArguments\n\nio::IO: The input stream from which to read the float.\nis_little_endian::Bool: A boolean indicating whether the float is in little-endian format.\n\nReturns\n\nFloat32: The read float value.\n\nRaises\n\nInvalidPfmFileFormat: If there is an error reading the bytes from the file.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._read_line-Tuple{Any}","page":"Detailed API","title":"jujutracer._read_line","text":"_read_line(io::IO)\n\nRead a line from the input buffer.\n\nArguments\n\nio::IO: The input stream from which to read the line.\n\nReturns\n\nString: The read line.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._rectangle_normal-Tuple{Point, Vec}","page":"Detailed API","title":"jujutracer._rectangle_normal","text":"_rectangle_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the rectangle\n\nArguments\n\np::Point: the point on the rectangle.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the rectangle's surface at the point.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._reflect_ray-Tuple{Vec, Point, Normal, Int64}","page":"Detailed API","title":"jujutracer._reflect_ray","text":"_reflect_ray(in_dir::Vec, p::Point, normal::Normal, depth::Int64)\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._sarrus-Tuple{Matrix}","page":"Detailed API","title":"jujutracer._sarrus","text":"_sarrus(Mat::Matrix)\n\nImplement the Sarrus method for calculation of the determinant of a 3x3 Matrix.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._sarrus-Tuple{Vec, Vec, Vec}","page":"Detailed API","title":"jujutracer._sarrus","text":"_sarrus(a::Vec, b::Vec, c::Vec)\n\nEfficiently computes the determinant of the 3x3 matrix whose columns are a, b, and c, without allocating a matrix.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._smooth_step-Tuple{Any, Any, Any}","page":"Detailed API","title":"jujutracer._smooth_step","text":"_smooth_step(x, edge0, edge1)\n\nCalculate a smooth step function value. Used in SpotLight for light modulation.\n\nArguments\n\nx: the input value.\nedge0: the lower edge of the step.\nedge1: the upper edge of the step.\n\nReturns\n\nFloat64: the smooth step value, clamped between 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._sphere_normal-Tuple{Point, Vec}","page":"Detailed API","title":"jujutracer._sphere_normal","text":"_sphere_normal(p::Point, dir::Vec)\n\nCalculate the normal vector of a point on the sphere.\n\nArguments\n\np::Point: the point on the sphere.\ndir::Vec: the direction vector of the ray.\n\nReturns\n\nNormal: the normal to the sphere's surface at the point.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._unsafe_inverse-Tuple{jujutracer.AbstractTransformation}","page":"Detailed API","title":"jujutracer._unsafe_inverse","text":"_unsafe_inverse(a::AbstractTransformation)\n\nReturn the inverse transformation without checking if the matrices are inverses of each other.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer._write_float!","page":"Detailed API","title":"jujutracer._write_float!","text":"_write_float!(f, io, endianness::Bool=true)\n\nWrite a Float32 value to the output stream with the correct endianness.\n\nArguments\n\nf: The float value to be written.\nio: The output stream to which the float will be written.\nendianness::Bool: A boolean indicating whether to write the float in little-endian format (default is true).\n\n\n\n\n\n","category":"function"},{"location":"detail/#jujutracer._γ_correction!-Tuple{hdrimg}","page":"Detailed API","title":"jujutracer._γ_correction!","text":"_γ_correction!(hdr::hdrimg; γ = 1.0)\n\nApply gamma correction to the HDR image using the formula: \n\nR_i  R_i^1γ\n\nArguments\n\nhdr::hdrimg: The HDR image to be gamma corrected.\nγ::Float64: The gamma value to be used for correction. Must be a positive number (default is 1.0).\n\nRaises\n\nArgumentError: If γ is not a positive number.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{AABB}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(axisbox::AABB)\n\nReturns the two points defining the axis-aligned bounding box (AABB) axisbox.\n\nArguments\n\naxisbox::AABB: the axis-aligned bounding box to be boxed.\n\nReturns\n\nTuple{Point, Point}: a tuple containing the two points defining the AABB, where the first point is the minimum corner and the second point is the maximum corner.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{Box}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(S::Box)::Tuple{Point, Point}\n\nReturns the bounding box of the box.\n\nArguments\n\nS::Box: The box for which to calculate the bounding box.\n\nReturns\n\nTuple{Point, Point}: A tuple containing the two opposite corners of the bounding box of the box.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{Circle}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(S::Circle)::Tuple{Point, Point}\n\nReturns the bounding box of the circle.\n\nArguments\n\nS::Circle: The circle for which to calculate the bounding box.\n\nReturns\n\nTuple{Point, Point}: A tuple containing the two opposite corners of the bounding box of the circle.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{Cone}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(S::Cone)::Tuple{Point, Point}\n\nReturns the bounding box of the cone.\n\nArguments\n\nS::Cone: The cone to get the bounding box of.\n\nReturns\n\nTuple{Point, Point}: A tuple containing the two corners of the bounding box.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{Cylinder}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(S::Cylinder)::Tuple{Point, Point}\n\nReturns the bounding box of the cylinder.\n\nArguments\n\nS::Cylinder: The cylinder for which to calculate the bounding box.\n\nReturns\n\nTuple{Point, Point}: A tuple containing the two opposite corners of the bounding box of the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{Parallelogram}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(S::Parallelogram)::Tuple{Point, Point}\n\nReturns the two points defining the bounding box of the parallelogram.\n\nArguments\n\nS::Parallelogram: the parallelogram to be boxed.\n\nReturns\n\nTuple{Point, Point}: a tuple containing the two points defining the bounding box of the parallelogram.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{Rectangle}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(S::Rectangle)::Tuple{Point, Point}\n\nReturns the bounding box of the rectangle.\n\nArguments\n\nS::Rectangle: The rectangle for which to calculate the bounding box.\n\nReturns\n\nTuple{Point, Point}: A tuple containing the two opposite corners of the bounding box of the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{Sphere}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(S::Sphere)::Tuple{Point, Point}\n\nReturns the bounding box of the sphere.\n\nArguments\n\nS::Sphere: The sphere for which to calculate the bounding box.\n\nReturns\n\nTuple{Point, Point}: A tuple containing the two opposite corners of the bounding box of the sphere.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{Triangle}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(S::Triangle)::Tuple{Point, Point}\n\nReturns the two points defining the bounding box of the triangle S.\n\nArguments\n\nS::Triangle: the triangle to be boxed.\n\nReturns\n\nTuple{Point, Point}: a tuple containing the two points defining the bounding box of the triangle.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.boxed-Tuple{Union{CSGDifference, CSGIntersection, CSGUnion}}","page":"Detailed API","title":"jujutracer.boxed","text":"boxed(CSG::Union{CSGUnion, CSGDifference, CSGIntersection})::Tuple{Point, Point}\n\nCalculates the bounding box of a CSG shape.\n\nArguments\n\nCSG::Union{CSGUnion, CSGDifference, CSGIntersection}: The CSG shape for which to calculate the bounding box.\n\nReturns\n\nTuple{Point, Point}: A tuple containing the two opposite corners of the bounding box of the CSG shape.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.create_onb_from_z-Tuple{Union{Normal, Vec}}","page":"Detailed API","title":"jujutracer.create_onb_from_z","text":"create_onb_from_z(normal::Union{Vec, Normal})\n\nCreates an orthonormal basis (ONB) from a given normal vector.\n\nArguments\n\nnormal::Union{Vec, Normal}: The NORMAL vector from which to create the ONB. It can be a Vec or Normal.\n\nReturns\n\nA tuple of three Vec objects representing the orthonormal basis vectors.\ne1: The first basis vector.\ne2: The second basis vector.\nnormal: The normal vector itself.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.get_matrix-Tuple{hdrimg}","page":"Detailed API","title":"jujutracer.get_matrix","text":"get_matrix(img::hdrimg)\n\nExtract the matrix from an HDR image.\n\nArguments\n\nimg::hdrimg: The HDR image from which to extract the matrix.\n\nReturns\n\nMatrix: The matrix representation of the HDR image.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.internal-Tuple{Box, Point}","page":"Detailed API","title":"jujutracer.internal","text":"internal(box::Box, P::Point)\n\nCheck if a point is inside the box.\n\nArguments\n\nbox::Box: The box to check.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the box, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.internal-Tuple{CSGDifference, Point}","page":"Detailed API","title":"jujutracer.internal","text":"internal(D::CSGDifference, P::Point)\n\nChecks if a point is inside the difference of two solid shapes.\n\nArguments\n\nD::CSGDifference: The difference of solid shapes.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the difference, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.internal-Tuple{CSGIntersection, Point}","page":"Detailed API","title":"jujutracer.internal","text":"internal(I::CSGIntersection, P::Point)\n\nChecks if a point is inside the intersection of two solid shapes.\n\nArguments\n\nI::CSGIntersection: The intersection of solid shapes.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the intersection, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.internal-Tuple{CSGUnion, Point}","page":"Detailed API","title":"jujutracer.internal","text":"internal(U::CSGUnion, P::Point)\n\nChecks if a point is inside the union of two solid shapes.\n\nArguments\n\nU::CSGUnion: The union of solid shapes.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the union, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.internal-Tuple{Cone, Point}","page":"Detailed API","title":"jujutracer.internal","text":"internal(S::Cone, P::Point)\n\nChecks if a point is inside a cone.\n\nArguments\n\nS::Cone: The cone to check.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the cone, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.internal-Tuple{Cylinder, Point}","page":"Detailed API","title":"jujutracer.internal","text":"internal(S::Cylinder, P::Point)\n\nChecks if a point is inside a cylinder.\n\nArguments\n\nS::Cylinder: The cylinder to check.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the cylinder, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.internal-Tuple{Sphere, Point}","page":"Detailed API","title":"jujutracer.internal","text":"internal(S::Sphere, P::Point)\n\nChecks if a point is inside a sphere.\n\nArguments\n\nS::Sphere: The sphere to check.\nP::Point: The point to check.\n\nReturns\n\nBool: true if the point is inside the sphere, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.intersected-Tuple{AABB, Ray}","page":"Detailed API","title":"jujutracer.intersected","text":"intersected(axisbox::AABB, ray::Ray)\n\nCheck if a ray intersects an axis-aligned bounding box (AABB).\n\nArguments\n\naxisbox::AABB: the axis-aligned bounding box to be checked for intersection.\nray::Ray: the ray to be checked for intersection with the AABB.\n\nReturns\n\nBool: true if the ray intersects the AABB, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.inverse-Tuple{jujutracer.AbstractTransformation}","page":"Detailed API","title":"jujutracer.inverse","text":"inverse(a::AbstractTransformation)\n\nReturn the inverse transformation.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.is_light_visible-Tuple{World, LightSource, Point}","page":"Detailed API","title":"jujutracer.is_light_visible","text":"is_light_visible(world::World, light::LightSource, point::Point)\n\nCheck if a point is visible from a light source in the given world.\n\nArguments\n\nworld::World: the world containing the scene.\nlight::LightSource: the light source to check visibility from.\npoint::Point: the point to check visibility to.\n\nReturns\n\nBool: true if the point is visible from the light source, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.is_light_visible-Tuple{World, SpotLight, Point}","page":"Detailed API","title":"jujutracer.is_light_visible","text":"is_light_visible(world::World, light::SpotLight, point::Point)\n\nCheck if a point is visible from a spotlight in the given world.\n\nArguments\n\nworld::World: the world containing the scene.\nlight::SpotLight: the spotlight to check visibility from.\npoint::Point: the point to check visibility to.\n\nReturns\n\nBool: true if the point is in the cone of light and visible, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.is_point_visible-Tuple{World, Point, Point}","page":"Detailed API","title":"jujutracer.is_point_visible","text":"is_point_visible(W::World, pos::Point, observer::Point)\n\nChecks if a point is visible from an observer's position in the world. See also is_light_visible.\n\nArguments\n\nW::World: the world containing the shapes\npos::Point: the position of the point to check visibility for\nobserver::Point: the position of the observer\n\nReturns\n\nIf the point is visible from the observer's position, returns true. Otherwise, returns false.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.norm-Tuple{Union{Normal, Vec}}","page":"Detailed API","title":"jujutracer.norm","text":"norm(v::Union{Vec, Normal})\n\nCalculates the norm of a vector.\n\nArguments\n\nv::Union{Vec, Normal}: The vector to be processed. Expected to be a Vec or Normal  of 3 values (x, y, z).\n\nReturns\n\nThe norm of the vector.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.normalize-Tuple{Union{Normal, Vec}}","page":"Detailed API","title":"jujutracer.normalize","text":"normalize(v::Union{Vec, Normal})\n\nReturn a normalized vector.\n\nArguments\n\nv::Vec: The vector to be normalized.\n\nReturns\n\nThe normalized vector.\n\nThrows\n\nArgumentError: If the vector is zero.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{AABB, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::AABB, ray::Ray)::Bool\n\nChecks if a ray intersects with the Axis-Aligned Bounding Box without calculating the exact intersection point.\n\nArguments\n\nS::AABB: The Axis-Aligned Bounding Box to check for intersection.\nray::Ray: The ray to check for intersection with the Axis-Aligned Bounding Box.\n\nReturns\n\nBool: true if the ray intersects with the Axis-Aligned Bounding Box, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{Box, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::Box, ray::Ray)::Bool\n\nChecks if a ray intersects with the box without calculating the exact intersection point.\n\nArguments\n\nS::Box: The box to check for intersection.\nray::Ray: The ray to check for intersection with the box.\n\nReturns\n\nBool: true if the ray intersects with the box, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{CSGDifference, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::CSGDifference, ray::Ray)::Bool\n\nChecks if a ray intersects with the CSG figure without calculating the exact intersection point.\n\nArguments\n\nS::CSGDifference: The CSG figure to check for intersection.\nray::Ray: The ray to check for intersection with the CSG figure.\n\nReturns\n\nBool: true if the ray intersects with the CSG figure, false otherwise.\n\nNote\n\nThis is not very quick...\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{CSGIntersection, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::CSGDifference, ray::Ray)::Bool\n\nChecks if a ray intersects with the CSG figure without calculating the exact intersection point.\n\nArguments\n\nS::CSGDifference: The CSG figure to check for intersection.\nray::Ray: The ray to check for intersection with the CSG figure.\n\nReturns\n\nBool: true if the ray intersects with the CSG figure, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{CSGUnion, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::CSGUnion, ray::Ray)::Bool\n\nChecks if a ray intersects with the CSG figure without calculating the exact intersection point.\n\nArguments\n\nS::CSGUnion: The CSG figure to check for intersection.\nray::Ray: The ray to check for intersection with the CSG figure.\n\nReturns\n\nBool: true if the ray intersects with the CSG figure, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{Circle, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::Circle, ray::Ray)::Bool\n\nChecks if a ray intersects with the circle without calculating the exact intersection point.\n\nArguments\n\nS::Circle: The circle to check for intersection.\nray::Ray: The ray to check for intersection with the circle.\n\nReturns\n\nBool: true if the ray intersects with the circle, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{Cone, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::Cone, ray::Ray)::Bool\n\nChecks if a ray intersects with the cone without calculating the exact intersection point.\n\nArguments\n\nS::Cone: The cone to check for intersection.\nray::Ray: The ray to check for intersection with the cone.\n\nReturns\n\nBool: true if the ray intersects with the cone, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{Cylinder, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::Cylinder, ray::Ray)::Bool\n\nChecks if a ray intersects with the cylinder without calculating the exact intersection point.\n\nArguments\n\nS::Cylinder: The cylinder to check for intersection.\nray::Ray: The ray to check for intersection with the cylinder.\n\nReturns\n\nBool: true if the ray intersects with the cylinder, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{Parallelogram, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::Parallelogram, ray::Ray)::Bool\n\nChecks if a ray intersects with the parallelogram without calculating the exact intersection point.\n\nArguments\n\nS::Parallelogram: The parallelogram to check for intersection.\nray::Ray: The ray to check for intersection with the parallelogram.\n\nReturns\n\nBool: true if the ray intersects with the parallelogram, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{Plane, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::Plane, ray::Ray)::Bool\n\nChecks if a ray intersects with the plane without calculating the exact intersection point.\n\nArguments\n\nS::Plane: The plane to check for intersection.\nray::Ray: The ray to check for intersection with the plane.\n\nReturns\n\nBool: true if the ray intersects with the plane, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{Rectangle, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::Rectangle, ray::Ray)::Bool\n\nChecks if a ray intersects with the rectangle without calculating the exact intersection point.\n\nArguments\n\nS::Rectangle: The triangle to check for intersection.\nray::Ray: The ray to check for intersection with the triangle.\n\nReturns\n\nBool: true if the ray intersects with the triangle, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{Sphere, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::Sphere, ray::Ray)::Bool\n\nChecks if a ray intersects with the sphere without calculating the exact intersection point.\n\nArguments\n\nS::Sphere: The circle to check for intersection.\nray::Ray: The ray to check for intersection with the circle.\n\nReturns\n\nBool: true if the ray intersects with the circle, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.quick_ray_intersection-Tuple{Triangle, Ray}","page":"Detailed API","title":"jujutracer.quick_ray_intersection","text":"quick_ray_intersection(S::Triangle, ray::Ray)::Bool\n\nChecks if a ray intersects with the triangle without calculating the exact intersection point.\n\nArguments\n\nS::Triangle: The triangle to check for intersection.\nray::Ray: The ray to check for intersection with the triangle.\n\nReturns\n\nBool: true if the ray intersects with the triangle, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.rand_pcg-Tuple{PCG}","page":"Detailed API","title":"jujutracer.rand_pcg","text":"rand_pcg(pcg::PCG)::UInt32\n\nGenerate a random 32-bit unsigned integer using the PCG algorithm.\n\nArguments\n\npcg::PCG: The PCG instance to use for random number generation.\n\nReturns\n\nRandom ::UInt32 unsigned integer.\n\nNotes\n\nThis function updates the internal state of the PCG instance atomically and returns a random number based on the current state.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.rand_unif_hemisphere-Tuple{PCG}","page":"Detailed API","title":"jujutracer.rand_unif_hemisphere","text":"rand_uniform_hemisphere(pcg::PCG)::Float64\n\nGenerate a random point (x,y,z) on the unit hemisphere using the PCG algorithm.\n\nArguments\n\npcg::PCG: The PCG instance to use for random number generation.\n\nReturns\n\nA tuple (x, y, z) representing the coordinates of the random point on the hemisphere.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.rand_uniform-Tuple{PCG}","page":"Detailed API","title":"jujutracer.rand_uniform","text":"rand_uniform(pcg::PCG)::Float64\n\nGenerate a random floating-point number in the range [0, 1) using the PCG algorithm.\n\nArguments\n\npcg::PCG: The PCG instance to use for random number generation.\n\nReturns\n\nRandom floating-point number in the range [0, 1).\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{AABB, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(axisbox::AABB, ray::Ray)\n\nCalculate the intersection of a ray and an axis-aligned bounding box (AABB).\n\nArguments\n\naxisbox::AABB: the axis-aligned bounding box to be intersected.\nray::Ray: the ray intersecting the AABB.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersections occur.\n\nNotes\n\nThis function checks if the ray intersects the AABB and, if so, finds the closest intersection point among the shapes contained within the AABB.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{Box, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(box::Box, ray::Ray)\n\nCalculate the intersection of a ray and a box.\n\nArguments\n\nbox::Box: The box to be intersected.\nray::Ray: The ray to intersect with the box.\n\nReturns\n\nHitRecord: The hit record of the first intersection, if any.\nnothing: If no intersection occurs.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{CSGDifference, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(D::CSGDifference, ray::Ray)\n\nCalculates the intersection of a ray with the difference of two solid shapes.\n\nArguments\n\nD::CSGDifference: The difference of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersection occurs.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{CSGIntersection, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(I::CSGIntersection, ray::Ray)\n\nCalculates the intersection of a ray with the intersection of two solid shapes.\n\nArguments\n\nI::CSGIntersection: The intersection of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersection occurs.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{CSGUnion, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(U::CSGUnion, ray::Ray)\n\nCalculates the intersection of a ray with the union of two solid shapes.\n\nArguments\n\nU::CSGUnion: The union of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersection occurs.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{Circle, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(S::Circle, ray::Ray)\n\nCalculate the intersection of a ray and a circle.\n\nArguments\n\nS::Circle: the circle to be intersected.\nray::Ray: the ray intersecting the circle.\n\nReturns\n\nHitRecord: The hit record of the intersection, if any.\nnothing: If no intersection occurs.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{Cone, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(s::Cone, r::Ray)\n\nCalculates the intersection of a ray and a cone.\n\nArguments\n\nS::Cone: the cone to be intersected\nray::Ray: the ray intersecting the cone\n\nReturns\n\nIf there is an intersection, returns a HitRecord containing the hit information. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{Cylinder, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(s::Cylinder, r::Ray)\n\nCalculates the intersection of a ray and a cylinder.\n\nArguments\n\nS::Cylinder: the sphere to be intersected\nray::Ray: the ray intersecting the sphere\n\nReturns\n\nIf there is an intersection, returns a HitRecord containing the hit information. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{Parallelogram, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(S::Parallelogram, r::Ray)\n\nCalculate the intersection of a ray and a plane.\n\nArguments\n\nS::Parallelogram: the parallelogram to be intersected.\nray::Ray: the ray intersecting the triangle.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersections occur.\n\nDifferently from the other shapes, ray_intersection(S::Parallelogram, ray::Ray) incorporates _parallelogram_normal and _point_to_uv\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{Plane, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(p::Plane, r::Ray)\n\nCalculate the intersection of a ray and a plane.\n\nArguments\n\nS::Plane: the plane to be intersected.\nray::Ray: the ray intersecting the plane.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{Rectangle, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(S::Rectangle, r::Ray)\n\nCalculate the intersection of a ray and a plane.\n\nArguments\n\nS::Rectangle: the rectangle to be intersected.\nray::Ray: the ray intersecting the rectangle.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{Sphere, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(s::Sphere, r::Ray)\n\nCalculates the intersection of a ray and a sphere.\n\nArguments\n\nS::Sphere: the sphere to be intersected\nray::Ray: the ray intersecting the sphere\n\nReturns\n\nIf there is an intersection, returns a HitRecord containing the hit information. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{Triangle, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(S::Triangle, r::Ray)\n\nCalculate the intersection of a ray and a triangle.\n\nArguments\n\nS::Triangle: the triangle to be intersected.\nray::Ray: the ray intersecting the triangle.\n\nReturns\n\nHitRecord: The hit record of the first shape hit, if any.\nnothing: If no intersections occur.\n\nDifferently from the other shapes, ray_intersection(S::Triangle, ray::Ray) incorporates _triangle_normal and _point_to_uv\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection-Tuple{World, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection","text":"ray_intersection(W::World, ray::Ray)\n\nCalculates the intersection of a ray with all shapes in the world.\n\nArguments\n\nW::World: the world containing the shapes\nray::Ray: the ray to be intersected with the shapes in the worlds\n\nReturns\n\nIf there is an intersection, returns a HitRecord containing the hit information. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection_list-Tuple{Box, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(box::Box, ray::Ray)\n\nCalculate all intersections of a ray with a box.\n\nArguments\n\nbox::Box: The box to be intersected.\nray::Ray: The ray to intersect with the box.\n\nReturns\n\nVector{HitRecord}: A list of hit records for the two intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection_list-Tuple{CSGDifference, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(D::CSGDifference, ray::Ray)\n\nCalculates all intersections of a ray with the difference of two solid shapes.\n\nArguments\n\nD::CSGDifference: The difference of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nVector{HitRecord}: A sorted list of hit records for all intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection_list-Tuple{CSGIntersection, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(I::CSGIntersection, ray::Ray)\n\nCalculates all intersections of a ray with the intersection of two solid shapes.\n\nArguments\n\nI::CSGIntersection: The intersection of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nVector{HitRecord}: A sorted list of hit records for all intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection_list-Tuple{CSGUnion, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(U::CSGUnion, ray::Ray)\n\nCalculates all intersections of a ray with the union of two solid shapes.\n\nArguments\n\nU::CSGUnion: The union of solid shapes.\nray::Ray: The ray to intersect.\n\nReturns\n\nVector{HitRecord}: A sorted list of hit records for all intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection_list-Tuple{Cone, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(S::Cone, ray::Ray)\n\nCalculates all intersections of a ray with a cone.\n\nArguments\n\nS::Cone: The cone to be intersected.\nray::Ray: The ray intersecting the cone.\n\nReturns\n\nVector{HitRecord}: A list of of the two hit records for the two intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection_list-Tuple{Cylinder, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(S::Cylinder, ray::Ray)\n\nCalculates all intersections of a ray with a cylinder.\n\nArguments\n\nS::Cylinder: The sphere to be intersected.\nray::Ray: The ray intersecting the sphere.\n\nReturns\n\nVector{HitRecord}: A list of of the two hit records for the two intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.ray_intersection_list-Tuple{Sphere, Ray}","page":"Detailed API","title":"jujutracer.ray_intersection_list","text":"ray_intersection_list(S::Sphere, ray::Ray)\n\nCalculates all intersections of a ray with a sphere.\n\nArguments\n\nS::Sphere: The sphere to be intersected.\nray::Ray: The ray intersecting the sphere.\n\nReturns\n\nVector{HitRecord}: A list of of the two hit records for the two intersections, ordered by distance.\nnothing: If no intersections occur.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.read_pfm_image-Tuple{Any}","page":"Detailed API","title":"jujutracer.read_pfm_image","text":"read_pfm_image(io::IO)\n\nRead a PFM image from an input stream.\n\nArguments\n\nio::IO: The input stream from which to read the PFM image.\n\nReturns\n\nhdrimg: The HDR image read from the PFM file.\n\nRaises\n\nInvalidPfmFileFormat: If the PFM file format is invalid or if there are issues reading the file.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.read_pfm_image-Tuple{String}","page":"Detailed API","title":"jujutracer.read_pfm_image","text":"read_pfm_image(filename::String)\n\nRead a PFM image from an input stream.\n\nArguments\n\nfilename::String: The filename ofthe image, expected to be .pfm.\n\nReturns\n\nhdrimg: The HDR image read from the PFM file.\n\nRaises\n\nInvalidPfmFileFormat: If the PFM file format is invalid or if there are issues reading the file.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.save_ldrimage-Tuple{Matrix, String}","page":"Detailed API","title":"jujutracer.save_ldrimage","text":"save_ldrimage(img_matrix::Matrix, filename::String)\n\nSave an LDR image to a file.\n\nArguments\n\nimg_matrix::Matrix: The matrix representation of the image to be saved.\nfilename::String: The name of the file to save the image to, including the file extension (\".png\" or \".jpg\").\n\nReturns\n\nString: The path to the saved file.\n\nRaises\n\nArgumentError: If the file extension is not valid or if the image values are not clamped.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.squared_norm-Tuple{Union{Normal, Vec}}","page":"Detailed API","title":"jujutracer.squared_norm","text":"squared_norm(v::Union{Vec, Normal})\n\nCalculates the squared norm of a vector.\n\nArguments\n\nv::Union{Vec, Normal}: The vector to be processed. Expected to be a struct of 3 values (x, y, z).\n\nReturns\n\nThe squared norm of the vector.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.to_string-Tuple{T} where T<:Union{Normal, Point, Vec}","page":"Detailed API","title":"jujutracer.to_string","text":"to_string(v::T) where {T<:Union{Point, Vec, Normal}}\n\nConverts a Point, Vec, or Normal object to a string representation.\n\nArguments\n\nv::T: The object to be converted. Expected to be a struct of 3 values (x, y, z).\n\nReturns\n\nA string representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.tone_mapping-Tuple{hdrimg}","page":"Detailed API","title":"jujutracer.tone_mapping","text":"tone_mapping(img::hdrimg; a=0.18, lum = nothing, γ = 1.0)\n\nApply tone mapping to the HDR image.\n\nArguments\n\nimg::hdrimg: The HDR image to be tone-mapped.\na::Float64: A positive value to be used in the normalization formula (default is 0.18).\nlum::Float64: The average luminosity of the image. If not provided, it will be calculated using _average_luminosity.\nγ::Float64: The gamma value to be used for correction. Must be a positive number (default is 1.0).\n\nReturns\n\nhdrimg: The tone-mapped HDR image.\n\n\n\n\n\n","category":"method"},{"location":"detail/#jujutracer.write_pfm_image","page":"Detailed API","title":"jujutracer.write_pfm_image","text":"write_pfm_image(img::hdrimg, io, endianness::Bool=true)\n\nWrite a PFM file encodiding the content of an hdrimg\n\nArguments\n\nimg::hdrimg: The HDR image to be written to the PFM file.\nio::IO: The output stream to which the PFM image will be written.\nendianness::Bool: A boolean indicating whether to write the float values in little-endian format (default is true).\n\n\n\n\n\n","category":"function"},{"location":"detail/#jujutracer.write_pfm_image-2","page":"Detailed API","title":"jujutracer.write_pfm_image","text":"write_pfm_image(img::hdrimg, filename::String, endianness::Bool=true)\n\nWrite a PFM file encoding the content of an hdrimg.\n\nArguments\n\nimg::hdrimg: The HDR image to be written to the PFM file.\nfilename::String: The file path where the PFM image will be saved, including the \".pfm\" extension.\nendianness::Bool: A boolean indicating whether to write the float values in little-endian format (default is true).\n\nRaises\n\nInvalidPfmFileFormat: If the file extension is not \".pfm\".\n\n\n\n\n\n","category":"function"},{"location":"#jujutracer-documentation","page":"Home","title":"jujutracer documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the package jujutracer.","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert a PFM file into a LDR format such as .png or .jpg. Need a and gamma values specified.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia main.jl <pfm_file> <a> <gamma> <output_file>","category":"page"}]
}
